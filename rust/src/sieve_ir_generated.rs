// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod sieve_ir {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE: [Message; 4] = [
  Message::NONE,
  Message::Relation,
  Message::PublicInputs,
  Message::PrivateInputs,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Message(pub u8);
#[allow(non_upper_case_globals)]
impl Message {
  pub const NONE: Self = Self(0);
  pub const Relation: Self = Self(1);
  pub const PublicInputs: Self = Self(2);
  pub const PrivateInputs: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Relation,
    Self::PublicInputs,
    Self::PrivateInputs,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Relation => Some("Relation"),
      Self::PublicInputs => Some("PublicInputs"),
      Self::PrivateInputs => Some("PrivateInputs"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Message {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Message {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Message {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Message {}
pub struct MessageUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum MessageT {
  NONE,
  Relation(Box<RelationT>),
  PublicInputs(Box<PublicInputsT>),
  PrivateInputs(Box<PrivateInputsT>),
}
impl Default for MessageT {
  fn default() -> Self {
    Self::NONE
  }
}
impl MessageT {
  pub fn message_type(&self) -> Message {
    match self {
      Self::NONE => Message::NONE,
      Self::Relation(_) => Message::Relation,
      Self::PublicInputs(_) => Message::PublicInputs,
      Self::PrivateInputs(_) => Message::PrivateInputs,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Relation(v) => Some(v.pack(fbb).as_union_value()),
      Self::PublicInputs(v) => Some(v.pack(fbb).as_union_value()),
      Self::PrivateInputs(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned RelationT, setting the union to NONE.
  pub fn take_relation(&mut self) -> Option<Box<RelationT>> {
    if let Self::Relation(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Relation(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the RelationT.
  pub fn as_relation(&self) -> Option<&RelationT> {
    if let Self::Relation(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the RelationT.
  pub fn as_relation_mut(&mut self) -> Option<&mut RelationT> {
    if let Self::Relation(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PublicInputsT, setting the union to NONE.
  pub fn take_public_inputs(&mut self) -> Option<Box<PublicInputsT>> {
    if let Self::PublicInputs(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PublicInputs(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PublicInputsT.
  pub fn as_public_inputs(&self) -> Option<&PublicInputsT> {
    if let Self::PublicInputs(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PublicInputsT.
  pub fn as_public_inputs_mut(&mut self) -> Option<&mut PublicInputsT> {
    if let Self::PublicInputs(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PrivateInputsT, setting the union to NONE.
  pub fn take_private_inputs(&mut self) -> Option<Box<PrivateInputsT>> {
    if let Self::PrivateInputs(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PrivateInputs(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PrivateInputsT.
  pub fn as_private_inputs(&self) -> Option<&PrivateInputsT> {
    if let Self::PrivateInputs(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PrivateInputsT.
  pub fn as_private_inputs_mut(&mut self) -> Option<&mut PrivateInputsT> {
    if let Self::PrivateInputs(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIRECTIVE_SET: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIRECTIVE_SET: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIRECTIVE_SET: [DirectiveSet; 3] = [
  DirectiveSet::NONE,
  DirectiveSet::Gate,
  DirectiveSet::Function,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DirectiveSet(pub u8);
#[allow(non_upper_case_globals)]
impl DirectiveSet {
  pub const NONE: Self = Self(0);
  pub const Gate: Self = Self(1);
  pub const Function: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Gate,
    Self::Function,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Gate => Some("Gate"),
      Self::Function => Some("Function"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DirectiveSet {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DirectiveSet {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DirectiveSet {
    type Output = DirectiveSet;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DirectiveSet {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DirectiveSet {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DirectiveSet {}
pub struct DirectiveSetUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum DirectiveSetT {
  NONE,
  Gate(Box<GateT>),
  Function(Box<FunctionT>),
}
impl Default for DirectiveSetT {
  fn default() -> Self {
    Self::NONE
  }
}
impl DirectiveSetT {
  pub fn directive_set_type(&self) -> DirectiveSet {
    match self {
      Self::NONE => DirectiveSet::NONE,
      Self::Gate(_) => DirectiveSet::Gate,
      Self::Function(_) => DirectiveSet::Function,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Gate(v) => Some(v.pack(fbb).as_union_value()),
      Self::Function(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned GateT, setting the union to NONE.
  pub fn take_gate(&mut self) -> Option<Box<GateT>> {
    if let Self::Gate(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Gate(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateT.
  pub fn as_gate(&self) -> Option<&GateT> {
    if let Self::Gate(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateT.
  pub fn as_gate_mut(&mut self) -> Option<&mut GateT> {
    if let Self::Gate(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned FunctionT, setting the union to NONE.
  pub fn take_function(&mut self) -> Option<Box<FunctionT>> {
    if let Self::Function(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Function(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the FunctionT.
  pub fn as_function(&self) -> Option<&FunctionT> {
    if let Self::Function(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the FunctionT.
  pub fn as_function_mut(&mut self) -> Option<&mut FunctionT> {
    if let Self::Function(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TYPE_U: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TYPE_U: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TYPE_U: [TypeU; 5] = [
  TypeU::NONE,
  TypeU::Field,
  TypeU::ExtField,
  TypeU::Ring,
  TypeU::PluginType,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TypeU(pub u8);
#[allow(non_upper_case_globals)]
impl TypeU {
  pub const NONE: Self = Self(0);
  pub const Field: Self = Self(1);
  pub const ExtField: Self = Self(2);
  pub const Ring: Self = Self(3);
  pub const PluginType: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Field,
    Self::ExtField,
    Self::Ring,
    Self::PluginType,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Field => Some("Field"),
      Self::ExtField => Some("ExtField"),
      Self::Ring => Some("Ring"),
      Self::PluginType => Some("PluginType"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TypeU {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TypeU {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TypeU {
    type Output = TypeU;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TypeU {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TypeU {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TypeU {}
pub struct TypeUUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum TypeUT {
  NONE,
  Field(Box<FieldT>),
  ExtField(Box<ExtFieldT>),
  Ring(Box<RingT>),
  PluginType(Box<PluginTypeT>),
}
impl Default for TypeUT {
  fn default() -> Self {
    Self::NONE
  }
}
impl TypeUT {
  pub fn type_u_type(&self) -> TypeU {
    match self {
      Self::NONE => TypeU::NONE,
      Self::Field(_) => TypeU::Field,
      Self::ExtField(_) => TypeU::ExtField,
      Self::Ring(_) => TypeU::Ring,
      Self::PluginType(_) => TypeU::PluginType,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Field(v) => Some(v.pack(fbb).as_union_value()),
      Self::ExtField(v) => Some(v.pack(fbb).as_union_value()),
      Self::Ring(v) => Some(v.pack(fbb).as_union_value()),
      Self::PluginType(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned FieldT, setting the union to NONE.
  pub fn take_field(&mut self) -> Option<Box<FieldT>> {
    if let Self::Field(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Field(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the FieldT.
  pub fn as_field(&self) -> Option<&FieldT> {
    if let Self::Field(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the FieldT.
  pub fn as_field_mut(&mut self) -> Option<&mut FieldT> {
    if let Self::Field(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ExtFieldT, setting the union to NONE.
  pub fn take_ext_field(&mut self) -> Option<Box<ExtFieldT>> {
    if let Self::ExtField(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ExtField(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ExtFieldT.
  pub fn as_ext_field(&self) -> Option<&ExtFieldT> {
    if let Self::ExtField(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ExtFieldT.
  pub fn as_ext_field_mut(&mut self) -> Option<&mut ExtFieldT> {
    if let Self::ExtField(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned RingT, setting the union to NONE.
  pub fn take_ring(&mut self) -> Option<Box<RingT>> {
    if let Self::Ring(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Ring(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the RingT.
  pub fn as_ring(&self) -> Option<&RingT> {
    if let Self::Ring(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the RingT.
  pub fn as_ring_mut(&mut self) -> Option<&mut RingT> {
    if let Self::Ring(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PluginTypeT, setting the union to NONE.
  pub fn take_plugin_type(&mut self) -> Option<Box<PluginTypeT>> {
    if let Self::PluginType(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PluginType(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PluginTypeT.
  pub fn as_plugin_type(&self) -> Option<&PluginTypeT> {
    if let Self::PluginType(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PluginTypeT.
  pub fn as_plugin_type_mut(&mut self) -> Option<&mut PluginTypeT> {
    if let Self::PluginType(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FUNCTION_BODY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FUNCTION_BODY: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FUNCTION_BODY: [FunctionBody; 3] = [
  FunctionBody::NONE,
  FunctionBody::Gates,
  FunctionBody::PluginBody,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FunctionBody(pub u8);
#[allow(non_upper_case_globals)]
impl FunctionBody {
  pub const NONE: Self = Self(0);
  pub const Gates: Self = Self(1);
  pub const PluginBody: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Gates,
    Self::PluginBody,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Gates => Some("Gates"),
      Self::PluginBody => Some("PluginBody"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FunctionBody {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FunctionBody {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FunctionBody {
    type Output = FunctionBody;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FunctionBody {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FunctionBody {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FunctionBody {}
pub struct FunctionBodyUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum FunctionBodyT {
  NONE,
  Gates(Box<GatesT>),
  PluginBody(Box<PluginBodyT>),
}
impl Default for FunctionBodyT {
  fn default() -> Self {
    Self::NONE
  }
}
impl FunctionBodyT {
  pub fn function_body_type(&self) -> FunctionBody {
    match self {
      Self::NONE => FunctionBody::NONE,
      Self::Gates(_) => FunctionBody::Gates,
      Self::PluginBody(_) => FunctionBody::PluginBody,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Gates(v) => Some(v.pack(fbb).as_union_value()),
      Self::PluginBody(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned GatesT, setting the union to NONE.
  pub fn take_gates(&mut self) -> Option<Box<GatesT>> {
    if let Self::Gates(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Gates(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GatesT.
  pub fn as_gates(&self) -> Option<&GatesT> {
    if let Self::Gates(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GatesT.
  pub fn as_gates_mut(&mut self) -> Option<&mut GatesT> {
    if let Self::Gates(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PluginBodyT, setting the union to NONE.
  pub fn take_plugin_body(&mut self) -> Option<Box<PluginBodyT>> {
    if let Self::PluginBody(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PluginBody(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PluginBodyT.
  pub fn as_plugin_body(&self) -> Option<&PluginBodyT> {
    if let Self::PluginBody(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PluginBodyT.
  pub fn as_plugin_body_mut(&mut self) -> Option<&mut PluginBodyT> {
    if let Self::PluginBody(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GATE_SET: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GATE_SET: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GATE_SET: [GateSet; 14] = [
  GateSet::NONE,
  GateSet::GateConstant,
  GateSet::GateAssertZero,
  GateSet::GateCopy,
  GateSet::GateAdd,
  GateSet::GateMul,
  GateSet::GateAddConstant,
  GateSet::GateMulConstant,
  GateSet::GatePublic,
  GateSet::GatePrivate,
  GateSet::GateNew,
  GateSet::GateDelete,
  GateSet::GateConvert,
  GateSet::GateCall,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GateSet(pub u8);
#[allow(non_upper_case_globals)]
impl GateSet {
  pub const NONE: Self = Self(0);
  pub const GateConstant: Self = Self(1);
  pub const GateAssertZero: Self = Self(2);
  pub const GateCopy: Self = Self(3);
  pub const GateAdd: Self = Self(4);
  pub const GateMul: Self = Self(5);
  pub const GateAddConstant: Self = Self(6);
  pub const GateMulConstant: Self = Self(7);
  pub const GatePublic: Self = Self(8);
  pub const GatePrivate: Self = Self(9);
  pub const GateNew: Self = Self(10);
  pub const GateDelete: Self = Self(11);
  pub const GateConvert: Self = Self(12);
  pub const GateCall: Self = Self(13);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::GateConstant,
    Self::GateAssertZero,
    Self::GateCopy,
    Self::GateAdd,
    Self::GateMul,
    Self::GateAddConstant,
    Self::GateMulConstant,
    Self::GatePublic,
    Self::GatePrivate,
    Self::GateNew,
    Self::GateDelete,
    Self::GateConvert,
    Self::GateCall,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::GateConstant => Some("GateConstant"),
      Self::GateAssertZero => Some("GateAssertZero"),
      Self::GateCopy => Some("GateCopy"),
      Self::GateAdd => Some("GateAdd"),
      Self::GateMul => Some("GateMul"),
      Self::GateAddConstant => Some("GateAddConstant"),
      Self::GateMulConstant => Some("GateMulConstant"),
      Self::GatePublic => Some("GatePublic"),
      Self::GatePrivate => Some("GatePrivate"),
      Self::GateNew => Some("GateNew"),
      Self::GateDelete => Some("GateDelete"),
      Self::GateConvert => Some("GateConvert"),
      Self::GateCall => Some("GateCall"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GateSet {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GateSet {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GateSet {
    type Output = GateSet;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GateSet {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GateSet {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GateSet {}
pub struct GateSetUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum GateSetT {
  NONE,
  GateConstant(Box<GateConstantT>),
  GateAssertZero(Box<GateAssertZeroT>),
  GateCopy(Box<GateCopyT>),
  GateAdd(Box<GateAddT>),
  GateMul(Box<GateMulT>),
  GateAddConstant(Box<GateAddConstantT>),
  GateMulConstant(Box<GateMulConstantT>),
  GatePublic(Box<GatePublicT>),
  GatePrivate(Box<GatePrivateT>),
  GateNew(Box<GateNewT>),
  GateDelete(Box<GateDeleteT>),
  GateConvert(Box<GateConvertT>),
  GateCall(Box<GateCallT>),
}
impl Default for GateSetT {
  fn default() -> Self {
    Self::NONE
  }
}
impl GateSetT {
  pub fn gate_set_type(&self) -> GateSet {
    match self {
      Self::NONE => GateSet::NONE,
      Self::GateConstant(_) => GateSet::GateConstant,
      Self::GateAssertZero(_) => GateSet::GateAssertZero,
      Self::GateCopy(_) => GateSet::GateCopy,
      Self::GateAdd(_) => GateSet::GateAdd,
      Self::GateMul(_) => GateSet::GateMul,
      Self::GateAddConstant(_) => GateSet::GateAddConstant,
      Self::GateMulConstant(_) => GateSet::GateMulConstant,
      Self::GatePublic(_) => GateSet::GatePublic,
      Self::GatePrivate(_) => GateSet::GatePrivate,
      Self::GateNew(_) => GateSet::GateNew,
      Self::GateDelete(_) => GateSet::GateDelete,
      Self::GateConvert(_) => GateSet::GateConvert,
      Self::GateCall(_) => GateSet::GateCall,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::GateConstant(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateAssertZero(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateCopy(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateAdd(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateMul(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateAddConstant(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateMulConstant(v) => Some(v.pack(fbb).as_union_value()),
      Self::GatePublic(v) => Some(v.pack(fbb).as_union_value()),
      Self::GatePrivate(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateNew(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateDelete(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateConvert(v) => Some(v.pack(fbb).as_union_value()),
      Self::GateCall(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned GateConstantT, setting the union to NONE.
  pub fn take_gate_constant(&mut self) -> Option<Box<GateConstantT>> {
    if let Self::GateConstant(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateConstant(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateConstantT.
  pub fn as_gate_constant(&self) -> Option<&GateConstantT> {
    if let Self::GateConstant(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateConstantT.
  pub fn as_gate_constant_mut(&mut self) -> Option<&mut GateConstantT> {
    if let Self::GateConstant(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateAssertZeroT, setting the union to NONE.
  pub fn take_gate_assert_zero(&mut self) -> Option<Box<GateAssertZeroT>> {
    if let Self::GateAssertZero(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateAssertZero(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateAssertZeroT.
  pub fn as_gate_assert_zero(&self) -> Option<&GateAssertZeroT> {
    if let Self::GateAssertZero(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateAssertZeroT.
  pub fn as_gate_assert_zero_mut(&mut self) -> Option<&mut GateAssertZeroT> {
    if let Self::GateAssertZero(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateCopyT, setting the union to NONE.
  pub fn take_gate_copy(&mut self) -> Option<Box<GateCopyT>> {
    if let Self::GateCopy(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateCopy(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateCopyT.
  pub fn as_gate_copy(&self) -> Option<&GateCopyT> {
    if let Self::GateCopy(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateCopyT.
  pub fn as_gate_copy_mut(&mut self) -> Option<&mut GateCopyT> {
    if let Self::GateCopy(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateAddT, setting the union to NONE.
  pub fn take_gate_add(&mut self) -> Option<Box<GateAddT>> {
    if let Self::GateAdd(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateAdd(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateAddT.
  pub fn as_gate_add(&self) -> Option<&GateAddT> {
    if let Self::GateAdd(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateAddT.
  pub fn as_gate_add_mut(&mut self) -> Option<&mut GateAddT> {
    if let Self::GateAdd(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateMulT, setting the union to NONE.
  pub fn take_gate_mul(&mut self) -> Option<Box<GateMulT>> {
    if let Self::GateMul(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateMul(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateMulT.
  pub fn as_gate_mul(&self) -> Option<&GateMulT> {
    if let Self::GateMul(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateMulT.
  pub fn as_gate_mul_mut(&mut self) -> Option<&mut GateMulT> {
    if let Self::GateMul(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateAddConstantT, setting the union to NONE.
  pub fn take_gate_add_constant(&mut self) -> Option<Box<GateAddConstantT>> {
    if let Self::GateAddConstant(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateAddConstant(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateAddConstantT.
  pub fn as_gate_add_constant(&self) -> Option<&GateAddConstantT> {
    if let Self::GateAddConstant(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateAddConstantT.
  pub fn as_gate_add_constant_mut(&mut self) -> Option<&mut GateAddConstantT> {
    if let Self::GateAddConstant(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateMulConstantT, setting the union to NONE.
  pub fn take_gate_mul_constant(&mut self) -> Option<Box<GateMulConstantT>> {
    if let Self::GateMulConstant(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateMulConstant(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateMulConstantT.
  pub fn as_gate_mul_constant(&self) -> Option<&GateMulConstantT> {
    if let Self::GateMulConstant(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateMulConstantT.
  pub fn as_gate_mul_constant_mut(&mut self) -> Option<&mut GateMulConstantT> {
    if let Self::GateMulConstant(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GatePublicT, setting the union to NONE.
  pub fn take_gate_public(&mut self) -> Option<Box<GatePublicT>> {
    if let Self::GatePublic(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GatePublic(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GatePublicT.
  pub fn as_gate_public(&self) -> Option<&GatePublicT> {
    if let Self::GatePublic(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GatePublicT.
  pub fn as_gate_public_mut(&mut self) -> Option<&mut GatePublicT> {
    if let Self::GatePublic(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GatePrivateT, setting the union to NONE.
  pub fn take_gate_private(&mut self) -> Option<Box<GatePrivateT>> {
    if let Self::GatePrivate(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GatePrivate(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GatePrivateT.
  pub fn as_gate_private(&self) -> Option<&GatePrivateT> {
    if let Self::GatePrivate(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GatePrivateT.
  pub fn as_gate_private_mut(&mut self) -> Option<&mut GatePrivateT> {
    if let Self::GatePrivate(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateNewT, setting the union to NONE.
  pub fn take_gate_new(&mut self) -> Option<Box<GateNewT>> {
    if let Self::GateNew(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateNew(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateNewT.
  pub fn as_gate_new(&self) -> Option<&GateNewT> {
    if let Self::GateNew(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateNewT.
  pub fn as_gate_new_mut(&mut self) -> Option<&mut GateNewT> {
    if let Self::GateNew(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateDeleteT, setting the union to NONE.
  pub fn take_gate_delete(&mut self) -> Option<Box<GateDeleteT>> {
    if let Self::GateDelete(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateDelete(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateDeleteT.
  pub fn as_gate_delete(&self) -> Option<&GateDeleteT> {
    if let Self::GateDelete(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateDeleteT.
  pub fn as_gate_delete_mut(&mut self) -> Option<&mut GateDeleteT> {
    if let Self::GateDelete(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateConvertT, setting the union to NONE.
  pub fn take_gate_convert(&mut self) -> Option<Box<GateConvertT>> {
    if let Self::GateConvert(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateConvert(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateConvertT.
  pub fn as_gate_convert(&self) -> Option<&GateConvertT> {
    if let Self::GateConvert(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateConvertT.
  pub fn as_gate_convert_mut(&mut self) -> Option<&mut GateConvertT> {
    if let Self::GateConvert(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GateCallT, setting the union to NONE.
  pub fn take_gate_call(&mut self) -> Option<Box<GateCallT>> {
    if let Self::GateCall(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GateCall(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GateCallT.
  pub fn as_gate_call(&self) -> Option<&GateCallT> {
    if let Self::GateCall(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GateCallT.
  pub fn as_gate_call_mut(&mut self) -> Option<&mut GateCallT> {
    if let Self::GateCall(v) = self { Some(v.as_mut()) } else { None }
  }
}
// struct Count, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Count(pub [u8; 16]);
impl Default for Count { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Count {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Count")
      .field("type_id", &self.type_id())
      .field("count", &self.count())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Count {}
impl<'a> flatbuffers::Follow<'a> for Count {
  type Inner = &'a Count;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Count>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Count {
  type Inner = &'a Count;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Count>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Count {
    type Output = Count;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Count as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Count {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Count {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    type_id: u8,
    count: u64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_type_id(type_id);
    s.set_count(count);
    s
  }

  pub fn type_id(&self) -> u8 {
    let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_type_id(&mut self, x: u8) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn count(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_count(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn unpack(&self) -> CountT {
    CountT {
      type_id: self.type_id(),
      count: self.count(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct CountT {
  pub type_id: u8,
  pub count: u64,
}
impl CountT {
  pub fn pack(&self) -> Count {
    Count::new(
      self.type_id,
      self.count,
    )
  }
}

// struct Conversion, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Conversion(pub [u8; 32]);
impl Default for Conversion { 
  fn default() -> Self { 
    Self([0; 32])
  }
}
impl core::fmt::Debug for Conversion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Conversion")
      .field("output_count", &self.output_count())
      .field("input_count", &self.input_count())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Conversion {}
impl<'a> flatbuffers::Follow<'a> for Conversion {
  type Inner = &'a Conversion;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Conversion>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Conversion {
  type Inner = &'a Conversion;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Conversion>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Conversion {
    type Output = Conversion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Conversion as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Conversion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Conversion {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    output_count: &Count,
    input_count: &Count,
  ) -> Self {
    let mut s = Self([0; 32]);
    s.set_output_count(output_count);
    s.set_input_count(input_count);
    s
  }

  pub fn output_count(&self) -> &Count {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[0..].as_ptr() as *const Count) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_output_count(&mut self, x: &Count) {
    self.0[0..0 + 16].copy_from_slice(&x.0)
  }

  pub fn input_count(&self) -> &Count {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[16..].as_ptr() as *const Count) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_input_count(&mut self, x: &Count) {
    self.0[16..16 + 16].copy_from_slice(&x.0)
  }

  pub fn unpack(&self) -> ConversionT {
    ConversionT {
      output_count: self.output_count().unpack(),
      input_count: self.input_count().unpack(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct ConversionT {
  pub output_count: CountT,
  pub input_count: CountT,
}
impl ConversionT {
  pub fn pack(&self) -> Conversion {
    Conversion::new(
      &self.output_count.pack(),
      &self.input_count.pack(),
    )
  }
}

// struct WireRange, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct WireRange(pub [u8; 16]);
impl Default for WireRange { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for WireRange {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("WireRange")
      .field("first_id", &self.first_id())
      .field("last_id", &self.last_id())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for WireRange {}
impl<'a> flatbuffers::Follow<'a> for WireRange {
  type Inner = &'a WireRange;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a WireRange>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a WireRange {
  type Inner = &'a WireRange;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<WireRange>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for WireRange {
    type Output = WireRange;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const WireRange as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for WireRange {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> WireRange {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    first_id: u64,
    last_id: u64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_first_id(first_id);
    s.set_last_id(last_id);
    s
  }

  pub fn first_id(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_first_id(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn last_id(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_last_id(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn unpack(&self) -> WireRangeT {
    WireRangeT {
      first_id: self.first_id(),
      last_id: self.last_id(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct WireRangeT {
  pub first_id: u64,
  pub last_id: u64,
}
impl WireRangeT {
  pub fn pack(&self) -> WireRange {
    WireRange::new(
      self.first_id,
      self.last_id,
    )
  }
}

pub enum RelationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Relation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Relation<'a> {
  type Inner = Relation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Relation<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_PLUGINS: flatbuffers::VOffsetT = 6;
  pub const VT_TYPES: flatbuffers::VOffsetT = 8;
  pub const VT_CONVERSIONS: flatbuffers::VOffsetT = 10;
  pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Relation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RelationArgs<'args>
  ) -> flatbuffers::WIPOffset<Relation<'bldr>> {
    let mut builder = RelationBuilder::new(_fbb);
    if let Some(x) = args.directives { builder.add_directives(x); }
    if let Some(x) = args.conversions { builder.add_conversions(x); }
    if let Some(x) = args.types { builder.add_types(x); }
    if let Some(x) = args.plugins { builder.add_plugins(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> RelationT {
    let version = self.version().map(|x| {
      x.to_string()
    });
    let plugins = self.plugins().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let types = self.types().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let conversions = self.conversions().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let directives = self.directives().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    RelationT {
      version,
      plugins,
      types,
      conversions,
      directives,
    }
  }

  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Relation::VT_VERSION, None)}
  }
  #[inline]
  pub fn plugins(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Relation::VT_PLUGINS, None)}
  }
  #[inline]
  pub fn types(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Type<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Type>>>>(Relation::VT_TYPES, None)}
  }
  #[inline]
  pub fn conversions(&self) -> Option<flatbuffers::Vector<'a, Conversion>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Conversion>>>(Relation::VT_CONVERSIONS, None)}
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive>>>>(Relation::VT_DIRECTIVES, None)}
  }
}

impl flatbuffers::Verifiable for Relation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("plugins", Self::VT_PLUGINS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Type>>>>("types", Self::VT_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Conversion>>>("conversions", Self::VT_CONVERSIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Directive>>>>("directives", Self::VT_DIRECTIVES, false)?
     .finish();
    Ok(())
  }
}
pub struct RelationArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plugins: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Type<'a>>>>>,
    pub conversions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Conversion>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>>>,
}
impl<'a> Default for RelationArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelationArgs {
      version: None,
      plugins: None,
      types: None,
      conversions: None,
      directives: None,
    }
  }
}

pub struct RelationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelationBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_VERSION, version);
  }
  #[inline]
  pub fn add_plugins(&mut self, plugins: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_PLUGINS, plugins);
  }
  #[inline]
  pub fn add_types(&mut self, types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Type<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_TYPES, types);
  }
  #[inline]
  pub fn add_conversions(&mut self, conversions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Conversion>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_CONVERSIONS, conversions);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directive<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Relation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Relation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Relation");
      ds.field("version", &self.version());
      ds.field("plugins", &self.plugins());
      ds.field("types", &self.types());
      ds.field("conversions", &self.conversions());
      ds.field("directives", &self.directives());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RelationT {
  pub version: Option<String>,
  pub plugins: Option<Vec<String>>,
  pub types: Option<Vec<TypeT>>,
  pub conversions: Option<Vec<ConversionT>>,
  pub directives: Option<Vec<DirectiveT>>,
}
impl Default for RelationT {
  fn default() -> Self {
    Self {
      version: None,
      plugins: None,
      types: None,
      conversions: None,
      directives: None,
    }
  }
}
impl RelationT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Relation<'b>> {
    let version = self.version.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let plugins = self.plugins.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let types = self.types.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let conversions = self.conversions.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let directives = self.directives.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Relation::create(_fbb, &RelationArgs{
      version,
      plugins,
      types,
      conversions,
      directives,
    })
  }
}
pub enum PublicInputsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PublicInputs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PublicInputs<'a> {
  type Inner = PublicInputs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PublicInputs<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PublicInputs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PublicInputsArgs<'args>
  ) -> flatbuffers::WIPOffset<PublicInputs<'bldr>> {
    let mut builder = PublicInputsBuilder::new(_fbb);
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PublicInputsT {
    let version = self.version().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      Box::new(x.unpack())
    });
    let inputs = self.inputs().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    PublicInputsT {
      version,
      type_,
      inputs,
    }
  }

  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PublicInputs::VT_VERSION, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<Type<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Type>>(PublicInputs::VT_TYPE_, None)}
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>>>(PublicInputs::VT_INPUTS, None)}
  }
}

impl flatbuffers::Verifiable for PublicInputs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Type>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>>>("inputs", Self::VT_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct PublicInputsArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<Type<'a>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>>>,
}
impl<'a> Default for PublicInputsArgs<'a> {
  #[inline]
  fn default() -> Self {
    PublicInputsArgs {
      version: None,
      type_: None,
      inputs: None,
    }
  }
}

pub struct PublicInputsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PublicInputsBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PublicInputs::VT_VERSION, version);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(PublicInputs::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PublicInputs::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PublicInputsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PublicInputsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PublicInputs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PublicInputs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PublicInputs");
      ds.field("version", &self.version());
      ds.field("type_", &self.type_());
      ds.field("inputs", &self.inputs());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PublicInputsT {
  pub version: Option<String>,
  pub type_: Option<Box<TypeT>>,
  pub inputs: Option<Vec<ValueT>>,
}
impl Default for PublicInputsT {
  fn default() -> Self {
    Self {
      version: None,
      type_: None,
      inputs: None,
    }
  }
}
impl PublicInputsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PublicInputs<'b>> {
    let version = self.version.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let inputs = self.inputs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    PublicInputs::create(_fbb, &PublicInputsArgs{
      version,
      type_,
      inputs,
    })
  }
}
pub enum PrivateInputsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrivateInputs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrivateInputs<'a> {
  type Inner = PrivateInputs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PrivateInputs<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PrivateInputs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PrivateInputsArgs<'args>
  ) -> flatbuffers::WIPOffset<PrivateInputs<'bldr>> {
    let mut builder = PrivateInputsBuilder::new(_fbb);
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PrivateInputsT {
    let version = self.version().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      Box::new(x.unpack())
    });
    let inputs = self.inputs().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    PrivateInputsT {
      version,
      type_,
      inputs,
    }
  }

  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PrivateInputs::VT_VERSION, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<Type<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Type>>(PrivateInputs::VT_TYPE_, None)}
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>>>(PrivateInputs::VT_INPUTS, None)}
  }
}

impl flatbuffers::Verifiable for PrivateInputs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Type>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>>>("inputs", Self::VT_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct PrivateInputsArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<Type<'a>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>>>,
}
impl<'a> Default for PrivateInputsArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrivateInputsArgs {
      version: None,
      type_: None,
      inputs: None,
    }
  }
}

pub struct PrivateInputsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrivateInputsBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrivateInputs::VT_VERSION, version);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(PrivateInputs::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrivateInputs::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrivateInputsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PrivateInputsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrivateInputs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PrivateInputs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PrivateInputs");
      ds.field("version", &self.version());
      ds.field("type_", &self.type_());
      ds.field("inputs", &self.inputs());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PrivateInputsT {
  pub version: Option<String>,
  pub type_: Option<Box<TypeT>>,
  pub inputs: Option<Vec<ValueT>>,
}
impl Default for PrivateInputsT {
  fn default() -> Self {
    Self {
      version: None,
      type_: None,
      inputs: None,
    }
  }
}
impl PrivateInputsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PrivateInputs<'b>> {
    let version = self.version.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let inputs = self.inputs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    PrivateInputs::create(_fbb, &PrivateInputsArgs{
      version,
      type_,
      inputs,
    })
  }
}
pub enum ValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Value<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Value<'a> {
  type Inner = Value<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Value<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Value { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ValueArgs<'args>
  ) -> flatbuffers::WIPOffset<Value<'bldr>> {
    let mut builder = ValueBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ValueT {
    let value = self.value().map(|x| {
      x.into_iter().collect()
    });
    ValueT {
      value,
    }
  }

  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Value::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Value<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ValueArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    ValueArgs {
      value: None,
    }
  }
}

pub struct ValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Value<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Value<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Value");
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ValueT {
  pub value: Option<Vec<u8>>,
}
impl Default for ValueT {
  fn default() -> Self {
    Self {
      value: None,
    }
  }
}
impl ValueT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Value<'b>> {
    let value = self.value.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    Value::create(_fbb, &ValueArgs{
      value,
    })
  }
}
pub enum DirectiveOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Directive<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Directive<'a> {
  type Inner = Directive<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Directive<'a> {
  pub const VT_DIRECTIVE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DIRECTIVE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Directive { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DirectiveArgs
  ) -> flatbuffers::WIPOffset<Directive<'bldr>> {
    let mut builder = DirectiveBuilder::new(_fbb);
    if let Some(x) = args.directive { builder.add_directive(x); }
    builder.add_directive_type(args.directive_type);
    builder.finish()
  }

  pub fn unpack(&self) -> DirectiveT {
    let directive = match self.directive_type() {
      DirectiveSet::NONE => DirectiveSetT::NONE,
      DirectiveSet::Gate => DirectiveSetT::Gate(Box::new(
        self.directive_as_gate()
            .expect("Invalid union table, expected `DirectiveSet::Gate`.")
            .unpack()
      )),
      DirectiveSet::Function => DirectiveSetT::Function(Box::new(
        self.directive_as_function()
            .expect("Invalid union table, expected `DirectiveSet::Function`.")
            .unpack()
      )),
      _ => DirectiveSetT::NONE,
    };
    DirectiveT {
      directive,
    }
  }

  #[inline]
  pub fn directive_type(&self) -> DirectiveSet {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DirectiveSet>(Directive::VT_DIRECTIVE_TYPE, Some(DirectiveSet::NONE)).unwrap()}
  }
  #[inline]
  pub fn directive(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Directive::VT_DIRECTIVE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate(&self) -> Option<Gate<'a>> {
    if self.directive_type() == DirectiveSet::Gate {
      self.directive().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Gate::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_function(&self) -> Option<Function<'a>> {
    if self.directive_type() == DirectiveSet::Function {
      self.directive().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Function::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Directive<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<DirectiveSet, _>("directive_type", Self::VT_DIRECTIVE_TYPE, "directive", Self::VT_DIRECTIVE, false, |key, v, pos| {
        match key {
          DirectiveSet::Gate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Gate>>("DirectiveSet::Gate", pos),
          DirectiveSet::Function => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Function>>("DirectiveSet::Function", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct DirectiveArgs {
    pub directive_type: DirectiveSet,
    pub directive: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DirectiveArgs {
  #[inline]
  fn default() -> Self {
    DirectiveArgs {
      directive_type: DirectiveSet::NONE,
      directive: None,
    }
  }
}

pub struct DirectiveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DirectiveBuilder<'a, 'b> {
  #[inline]
  pub fn add_directive_type(&mut self, directive_type: DirectiveSet) {
    self.fbb_.push_slot::<DirectiveSet>(Directive::VT_DIRECTIVE_TYPE, directive_type, DirectiveSet::NONE);
  }
  #[inline]
  pub fn add_directive(&mut self, directive: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Directive::VT_DIRECTIVE, directive);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirectiveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DirectiveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Directive<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Directive<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Directive");
      ds.field("directive_type", &self.directive_type());
      match self.directive_type() {
        DirectiveSet::Gate => {
          if let Some(x) = self.directive_as_gate() {
            ds.field("directive", &x)
          } else {
            ds.field("directive", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        DirectiveSet::Function => {
          if let Some(x) = self.directive_as_function() {
            ds.field("directive", &x)
          } else {
            ds.field("directive", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("directive", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DirectiveT {
  pub directive: DirectiveSetT,
}
impl Default for DirectiveT {
  fn default() -> Self {
    Self {
      directive: DirectiveSetT::NONE,
    }
  }
}
impl DirectiveT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Directive<'b>> {
    let directive_type = self.directive.directive_set_type();
    let directive = self.directive.pack(_fbb);
    Directive::create(_fbb, &DirectiveArgs{
      directive_type,
      directive,
    })
  }
}
pub enum TypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Type<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Type<'a> {
  type Inner = Type<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Type<'a> {
  pub const VT_ELEMENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ELEMENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Type { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TypeArgs
  ) -> flatbuffers::WIPOffset<Type<'bldr>> {
    let mut builder = TypeBuilder::new(_fbb);
    if let Some(x) = args.element { builder.add_element(x); }
    builder.add_element_type(args.element_type);
    builder.finish()
  }

  pub fn unpack(&self) -> TypeT {
    let element = match self.element_type() {
      TypeU::NONE => TypeUT::NONE,
      TypeU::Field => TypeUT::Field(Box::new(
        self.element_as_field()
            .expect("Invalid union table, expected `TypeU::Field`.")
            .unpack()
      )),
      TypeU::ExtField => TypeUT::ExtField(Box::new(
        self.element_as_ext_field()
            .expect("Invalid union table, expected `TypeU::ExtField`.")
            .unpack()
      )),
      TypeU::Ring => TypeUT::Ring(Box::new(
        self.element_as_ring()
            .expect("Invalid union table, expected `TypeU::Ring`.")
            .unpack()
      )),
      TypeU::PluginType => TypeUT::PluginType(Box::new(
        self.element_as_plugin_type()
            .expect("Invalid union table, expected `TypeU::PluginType`.")
            .unpack()
      )),
      _ => TypeUT::NONE,
    };
    TypeT {
      element,
    }
  }

  #[inline]
  pub fn element_type(&self) -> TypeU {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TypeU>(Type::VT_ELEMENT_TYPE, Some(TypeU::NONE)).unwrap()}
  }
  #[inline]
  pub fn element(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Type::VT_ELEMENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_field(&self) -> Option<Field<'a>> {
    if self.element_type() == TypeU::Field {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Field::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_ext_field(&self) -> Option<ExtField<'a>> {
    if self.element_type() == TypeU::ExtField {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ExtField::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_ring(&self) -> Option<Ring<'a>> {
    if self.element_type() == TypeU::Ring {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Ring::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_plugin_type(&self) -> Option<PluginType<'a>> {
    if self.element_type() == TypeU::PluginType {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PluginType::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Type<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<TypeU, _>("element_type", Self::VT_ELEMENT_TYPE, "element", Self::VT_ELEMENT, false, |key, v, pos| {
        match key {
          TypeU::Field => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Field>>("TypeU::Field", pos),
          TypeU::ExtField => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExtField>>("TypeU::ExtField", pos),
          TypeU::Ring => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Ring>>("TypeU::Ring", pos),
          TypeU::PluginType => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PluginType>>("TypeU::PluginType", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct TypeArgs {
    pub element_type: TypeU,
    pub element: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for TypeArgs {
  #[inline]
  fn default() -> Self {
    TypeArgs {
      element_type: TypeU::NONE,
      element: None,
    }
  }
}

pub struct TypeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_element_type(&mut self, element_type: TypeU) {
    self.fbb_.push_slot::<TypeU>(Type::VT_ELEMENT_TYPE, element_type, TypeU::NONE);
  }
  #[inline]
  pub fn add_element(&mut self, element: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Type::VT_ELEMENT, element);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Type<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Type<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Type");
      ds.field("element_type", &self.element_type());
      match self.element_type() {
        TypeU::Field => {
          if let Some(x) = self.element_as_field() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        TypeU::ExtField => {
          if let Some(x) = self.element_as_ext_field() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        TypeU::Ring => {
          if let Some(x) = self.element_as_ring() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        TypeU::PluginType => {
          if let Some(x) = self.element_as_plugin_type() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("element", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TypeT {
  pub element: TypeUT,
}
impl Default for TypeT {
  fn default() -> Self {
    Self {
      element: TypeUT::NONE,
    }
  }
}
impl TypeT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Type<'b>> {
    let element_type = self.element.type_u_type();
    let element = self.element.pack(_fbb);
    Type::create(_fbb, &TypeArgs{
      element_type,
      element,
    })
  }
}
pub enum FieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Field<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Field<'a> {
  type Inner = Field<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Field<'a> {
  pub const VT_MODULO: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Field { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FieldArgs<'args>
  ) -> flatbuffers::WIPOffset<Field<'bldr>> {
    let mut builder = FieldBuilder::new(_fbb);
    if let Some(x) = args.modulo { builder.add_modulo(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> FieldT {
    let modulo = self.modulo().map(|x| {
      Box::new(x.unpack())
    });
    FieldT {
      modulo,
    }
  }

  #[inline]
  pub fn modulo(&self) -> Option<Value<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Value>>(Field::VT_MODULO, None)}
  }
}

impl flatbuffers::Verifiable for Field<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Value>>("modulo", Self::VT_MODULO, false)?
     .finish();
    Ok(())
  }
}
pub struct FieldArgs<'a> {
    pub modulo: Option<flatbuffers::WIPOffset<Value<'a>>>,
}
impl<'a> Default for FieldArgs<'a> {
  #[inline]
  fn default() -> Self {
    FieldArgs {
      modulo: None,
    }
  }
}

pub struct FieldBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FieldBuilder<'a, 'b> {
  #[inline]
  pub fn add_modulo(&mut self, modulo: flatbuffers::WIPOffset<Value<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Value>>(Field::VT_MODULO, modulo);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Field<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Field");
      ds.field("modulo", &self.modulo());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FieldT {
  pub modulo: Option<Box<ValueT>>,
}
impl Default for FieldT {
  fn default() -> Self {
    Self {
      modulo: None,
    }
  }
}
impl FieldT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Field<'b>> {
    let modulo = self.modulo.as_ref().map(|x|{
      x.pack(_fbb)
    });
    Field::create(_fbb, &FieldArgs{
      modulo,
    })
  }
}
pub enum ExtFieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExtField<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExtField<'a> {
  type Inner = ExtField<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExtField<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_DEGREE: flatbuffers::VOffsetT = 6;
  pub const VT_MODULUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExtField { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExtFieldArgs
  ) -> flatbuffers::WIPOffset<ExtField<'bldr>> {
    let mut builder = ExtFieldBuilder::new(_fbb);
    builder.add_modulus(args.modulus);
    builder.add_degree(args.degree);
    builder.add_index(args.index);
    builder.finish()
  }

  pub fn unpack(&self) -> ExtFieldT {
    let index = self.index();
    let degree = self.degree();
    let modulus = self.modulus();
    ExtFieldT {
      index,
      degree,
      modulus,
    }
  }

  #[inline]
  pub fn index(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ExtField::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn degree(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExtField::VT_DEGREE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn modulus(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExtField::VT_MODULUS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ExtField<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("index", Self::VT_INDEX, false)?
     .visit_field::<u64>("degree", Self::VT_DEGREE, false)?
     .visit_field::<u64>("modulus", Self::VT_MODULUS, false)?
     .finish();
    Ok(())
  }
}
pub struct ExtFieldArgs {
    pub index: u8,
    pub degree: u64,
    pub modulus: u64,
}
impl<'a> Default for ExtFieldArgs {
  #[inline]
  fn default() -> Self {
    ExtFieldArgs {
      index: 0,
      degree: 0,
      modulus: 0,
    }
  }
}

pub struct ExtFieldBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExtFieldBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: u8) {
    self.fbb_.push_slot::<u8>(ExtField::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_degree(&mut self, degree: u64) {
    self.fbb_.push_slot::<u64>(ExtField::VT_DEGREE, degree, 0);
  }
  #[inline]
  pub fn add_modulus(&mut self, modulus: u64) {
    self.fbb_.push_slot::<u64>(ExtField::VT_MODULUS, modulus, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExtFieldBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExtFieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExtField<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExtField<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExtField");
      ds.field("index", &self.index());
      ds.field("degree", &self.degree());
      ds.field("modulus", &self.modulus());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ExtFieldT {
  pub index: u8,
  pub degree: u64,
  pub modulus: u64,
}
impl Default for ExtFieldT {
  fn default() -> Self {
    Self {
      index: 0,
      degree: 0,
      modulus: 0,
    }
  }
}
impl ExtFieldT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ExtField<'b>> {
    let index = self.index;
    let degree = self.degree;
    let modulus = self.modulus;
    ExtField::create(_fbb, &ExtFieldArgs{
      index,
      degree,
      modulus,
    })
  }
}
pub enum RingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Ring<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ring<'a> {
  type Inner = Ring<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Ring<'a> {
  pub const VT_NBITS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Ring { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RingArgs
  ) -> flatbuffers::WIPOffset<Ring<'bldr>> {
    let mut builder = RingBuilder::new(_fbb);
    builder.add_nbits(args.nbits);
    builder.finish()
  }

  pub fn unpack(&self) -> RingT {
    let nbits = self.nbits();
    RingT {
      nbits,
    }
  }

  #[inline]
  pub fn nbits(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Ring::VT_NBITS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Ring<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("nbits", Self::VT_NBITS, false)?
     .finish();
    Ok(())
  }
}
pub struct RingArgs {
    pub nbits: u64,
}
impl<'a> Default for RingArgs {
  #[inline]
  fn default() -> Self {
    RingArgs {
      nbits: 0,
    }
  }
}

pub struct RingBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RingBuilder<'a, 'b> {
  #[inline]
  pub fn add_nbits(&mut self, nbits: u64) {
    self.fbb_.push_slot::<u64>(Ring::VT_NBITS, nbits, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RingBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ring<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Ring<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Ring");
      ds.field("nbits", &self.nbits());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RingT {
  pub nbits: u64,
}
impl Default for RingT {
  fn default() -> Self {
    Self {
      nbits: 0,
    }
  }
}
impl RingT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Ring<'b>> {
    let nbits = self.nbits;
    Ring::create(_fbb, &RingArgs{
      nbits,
    })
  }
}
pub enum PluginTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PluginType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginType<'a> {
  type Inner = PluginType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PluginType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OPERATION: flatbuffers::VOffsetT = 6;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PluginType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PluginTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<PluginType<'bldr>> {
    let mut builder = PluginTypeBuilder::new(_fbb);
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.operation { builder.add_operation(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PluginTypeT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let operation = self.operation().map(|x| {
      x.to_string()
    });
    let params = self.params().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    PluginTypeT {
      name,
      operation,
      params,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginType::VT_NAME, None)}
  }
  #[inline]
  pub fn operation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginType::VT_OPERATION, None)}
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PluginType::VT_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for PluginType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operation", Self::VT_OPERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("params", Self::VT_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct PluginTypeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for PluginTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    PluginTypeArgs {
      name: None,
      operation: None,
      params: None,
    }
  }
}

pub struct PluginTypeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PluginTypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginType::VT_NAME, name);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginType::VT_OPERATION, operation);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginType::VT_PARAMS, params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PluginTypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PluginTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PluginType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PluginType");
      ds.field("name", &self.name());
      ds.field("operation", &self.operation());
      ds.field("params", &self.params());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PluginTypeT {
  pub name: Option<String>,
  pub operation: Option<String>,
  pub params: Option<Vec<String>>,
}
impl Default for PluginTypeT {
  fn default() -> Self {
    Self {
      name: None,
      operation: None,
      params: None,
    }
  }
}
impl PluginTypeT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PluginType<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let operation = self.operation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let params = self.params.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    PluginType::create(_fbb, &PluginTypeArgs{
      name,
      operation,
      params,
    })
  }
}
pub enum GateConstantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateConstant<'a> {
  type Inner = GateConstant<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateConstant<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_CONSTANT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateConstant { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateConstantArgs<'args>
  ) -> flatbuffers::WIPOffset<GateConstant<'bldr>> {
    let mut builder = GateConstantBuilder::new(_fbb);
    builder.add_out_id(args.out_id);
    if let Some(x) = args.constant { builder.add_constant(x); }
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateConstantT {
    let type_id = self.type_id();
    let out_id = self.out_id();
    let constant = self.constant().map(|x| {
      x.into_iter().collect()
    });
    GateConstantT {
      type_id,
      out_id,
      constant,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateConstant::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConstant::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn constant(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateConstant::VT_CONSTANT, None)}
  }
}

impl flatbuffers::Verifiable for GateConstant<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("constant", Self::VT_CONSTANT, false)?
     .finish();
    Ok(())
  }
}
pub struct GateConstantArgs<'a> {
    pub type_id: u8,
    pub out_id: u64,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GateConstantArgs<'a> {
  #[inline]
  fn default() -> Self {
    GateConstantArgs {
      type_id: 0,
      out_id: 0,
      constant: None,
    }
  }
}

pub struct GateConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateConstant::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateConstant::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateConstant<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateConstant");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("constant", &self.constant());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateConstantT {
  pub type_id: u8,
  pub out_id: u64,
  pub constant: Option<Vec<u8>>,
}
impl Default for GateConstantT {
  fn default() -> Self {
    Self {
      type_id: 0,
      out_id: 0,
      constant: None,
    }
  }
}
impl GateConstantT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateConstant<'b>> {
    let type_id = self.type_id;
    let out_id = self.out_id;
    let constant = self.constant.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    GateConstant::create(_fbb, &GateConstantArgs{
      type_id,
      out_id,
      constant,
    })
  }
}
pub enum GateAssertZeroOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateAssertZero<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAssertZero<'a> {
  type Inner = GateAssertZero<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateAssertZero<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_IN_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateAssertZero { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateAssertZeroArgs
  ) -> flatbuffers::WIPOffset<GateAssertZero<'bldr>> {
    let mut builder = GateAssertZeroBuilder::new(_fbb);
    builder.add_in_id(args.in_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateAssertZeroT {
    let type_id = self.type_id();
    let in_id = self.in_id();
    GateAssertZeroT {
      type_id,
      in_id,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateAssertZero::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAssertZero::VT_IN_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateAssertZero<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("in_id", Self::VT_IN_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateAssertZeroArgs {
    pub type_id: u8,
    pub in_id: u64,
}
impl<'a> Default for GateAssertZeroArgs {
  #[inline]
  fn default() -> Self {
    GateAssertZeroArgs {
      type_id: 0,
      in_id: 0,
    }
  }
}

pub struct GateAssertZeroBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAssertZeroBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateAssertZero::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateAssertZero::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAssertZeroBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAssertZeroBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAssertZero<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateAssertZero<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateAssertZero");
      ds.field("type_id", &self.type_id());
      ds.field("in_id", &self.in_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateAssertZeroT {
  pub type_id: u8,
  pub in_id: u64,
}
impl Default for GateAssertZeroT {
  fn default() -> Self {
    Self {
      type_id: 0,
      in_id: 0,
    }
  }
}
impl GateAssertZeroT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateAssertZero<'b>> {
    let type_id = self.type_id;
    let in_id = self.in_id;
    GateAssertZero::create(_fbb, &GateAssertZeroArgs{
      type_id,
      in_id,
    })
  }
}
pub enum GateCopyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateCopy<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateCopy<'a> {
  type Inner = GateCopy<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateCopy<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_IN_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateCopy { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateCopyArgs<'args>
  ) -> flatbuffers::WIPOffset<GateCopy<'bldr>> {
    let mut builder = GateCopyBuilder::new(_fbb);
    if let Some(x) = args.in_id { builder.add_in_id(x); }
    if let Some(x) = args.out_id { builder.add_out_id(x); }
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateCopyT {
    let type_id = self.type_id();
    let out_id = self.out_id().map(|x| {
      x.unpack()
    });
    let in_id = self.in_id().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    GateCopyT {
      type_id,
      out_id,
      in_id,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateCopy::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> Option<&'a WireRange> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WireRange>(GateCopy::VT_OUT_ID, None)}
  }
  #[inline]
  pub fn in_id(&self) -> Option<flatbuffers::Vector<'a, WireRange>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, WireRange>>>(GateCopy::VT_IN_ID, None)}
  }
}

impl flatbuffers::Verifiable for GateCopy<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<WireRange>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, WireRange>>>("in_id", Self::VT_IN_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateCopyArgs<'a> {
    pub type_id: u8,
    pub out_id: Option<&'a WireRange>,
    pub in_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, WireRange>>>,
}
impl<'a> Default for GateCopyArgs<'a> {
  #[inline]
  fn default() -> Self {
    GateCopyArgs {
      type_id: 0,
      out_id: None,
      in_id: None,
    }
  }
}

pub struct GateCopyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateCopyBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateCopy::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: &WireRange) {
    self.fbb_.push_slot_always::<&WireRange>(GateCopy::VT_OUT_ID, out_id);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b , WireRange>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCopy::VT_IN_ID, in_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateCopyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateCopyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateCopy<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateCopy<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateCopy");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("in_id", &self.in_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateCopyT {
  pub type_id: u8,
  pub out_id: Option<WireRangeT>,
  pub in_id: Option<Vec<WireRangeT>>,
}
impl Default for GateCopyT {
  fn default() -> Self {
    Self {
      type_id: 0,
      out_id: None,
      in_id: None,
    }
  }
}
impl GateCopyT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateCopy<'b>> {
    let type_id = self.type_id;
    let out_id_tmp = self.out_id.as_ref().map(|x| x.pack());
    let out_id = out_id_tmp.as_ref();
    let in_id = self.in_id.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    GateCopy::create(_fbb, &GateCopyArgs{
      type_id,
      out_id,
      in_id,
    })
  }
}
pub enum GateAddOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateAdd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAdd<'a> {
  type Inner = GateAdd<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateAdd<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_LEFT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_RIGHT_ID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateAdd { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateAddArgs
  ) -> flatbuffers::WIPOffset<GateAdd<'bldr>> {
    let mut builder = GateAddBuilder::new(_fbb);
    builder.add_right_id(args.right_id);
    builder.add_left_id(args.left_id);
    builder.add_out_id(args.out_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateAddT {
    let type_id = self.type_id();
    let out_id = self.out_id();
    let left_id = self.left_id();
    let right_id = self.right_id();
    GateAddT {
      type_id,
      out_id,
      left_id,
      right_id,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateAdd::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAdd::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn left_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAdd::VT_LEFT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn right_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAdd::VT_RIGHT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateAdd<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<u64>("left_id", Self::VT_LEFT_ID, false)?
     .visit_field::<u64>("right_id", Self::VT_RIGHT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateAddArgs {
    pub type_id: u8,
    pub out_id: u64,
    pub left_id: u64,
    pub right_id: u64,
}
impl<'a> Default for GateAddArgs {
  #[inline]
  fn default() -> Self {
    GateAddArgs {
      type_id: 0,
      out_id: 0,
      left_id: 0,
      right_id: 0,
    }
  }
}

pub struct GateAddBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateAdd::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateAdd::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_left_id(&mut self, left_id: u64) {
    self.fbb_.push_slot::<u64>(GateAdd::VT_LEFT_ID, left_id, 0);
  }
  #[inline]
  pub fn add_right_id(&mut self, right_id: u64) {
    self.fbb_.push_slot::<u64>(GateAdd::VT_RIGHT_ID, right_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAdd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateAdd<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateAdd");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("left_id", &self.left_id());
      ds.field("right_id", &self.right_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateAddT {
  pub type_id: u8,
  pub out_id: u64,
  pub left_id: u64,
  pub right_id: u64,
}
impl Default for GateAddT {
  fn default() -> Self {
    Self {
      type_id: 0,
      out_id: 0,
      left_id: 0,
      right_id: 0,
    }
  }
}
impl GateAddT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateAdd<'b>> {
    let type_id = self.type_id;
    let out_id = self.out_id;
    let left_id = self.left_id;
    let right_id = self.right_id;
    GateAdd::create(_fbb, &GateAddArgs{
      type_id,
      out_id,
      left_id,
      right_id,
    })
  }
}
pub enum GateMulOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateMul<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMul<'a> {
  type Inner = GateMul<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateMul<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_LEFT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_RIGHT_ID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateMul { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateMulArgs
  ) -> flatbuffers::WIPOffset<GateMul<'bldr>> {
    let mut builder = GateMulBuilder::new(_fbb);
    builder.add_right_id(args.right_id);
    builder.add_left_id(args.left_id);
    builder.add_out_id(args.out_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateMulT {
    let type_id = self.type_id();
    let out_id = self.out_id();
    let left_id = self.left_id();
    let right_id = self.right_id();
    GateMulT {
      type_id,
      out_id,
      left_id,
      right_id,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateMul::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMul::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn left_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMul::VT_LEFT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn right_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMul::VT_RIGHT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateMul<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<u64>("left_id", Self::VT_LEFT_ID, false)?
     .visit_field::<u64>("right_id", Self::VT_RIGHT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateMulArgs {
    pub type_id: u8,
    pub out_id: u64,
    pub left_id: u64,
    pub right_id: u64,
}
impl<'a> Default for GateMulArgs {
  #[inline]
  fn default() -> Self {
    GateMulArgs {
      type_id: 0,
      out_id: 0,
      left_id: 0,
      right_id: 0,
    }
  }
}

pub struct GateMulBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateMul::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateMul::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_left_id(&mut self, left_id: u64) {
    self.fbb_.push_slot::<u64>(GateMul::VT_LEFT_ID, left_id, 0);
  }
  #[inline]
  pub fn add_right_id(&mut self, right_id: u64) {
    self.fbb_.push_slot::<u64>(GateMul::VT_RIGHT_ID, right_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMul<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateMul<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateMul");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("left_id", &self.left_id());
      ds.field("right_id", &self.right_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateMulT {
  pub type_id: u8,
  pub out_id: u64,
  pub left_id: u64,
  pub right_id: u64,
}
impl Default for GateMulT {
  fn default() -> Self {
    Self {
      type_id: 0,
      out_id: 0,
      left_id: 0,
      right_id: 0,
    }
  }
}
impl GateMulT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateMul<'b>> {
    let type_id = self.type_id;
    let out_id = self.out_id;
    let left_id = self.left_id;
    let right_id = self.right_id;
    GateMul::create(_fbb, &GateMulArgs{
      type_id,
      out_id,
      left_id,
      right_id,
    })
  }
}
pub enum GateAddConstantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateAddConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAddConstant<'a> {
  type Inner = GateAddConstant<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateAddConstant<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_IN_ID: flatbuffers::VOffsetT = 8;
  pub const VT_CONSTANT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateAddConstant { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateAddConstantArgs<'args>
  ) -> flatbuffers::WIPOffset<GateAddConstant<'bldr>> {
    let mut builder = GateAddConstantBuilder::new(_fbb);
    builder.add_in_id(args.in_id);
    builder.add_out_id(args.out_id);
    if let Some(x) = args.constant { builder.add_constant(x); }
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateAddConstantT {
    let type_id = self.type_id();
    let out_id = self.out_id();
    let in_id = self.in_id();
    let constant = self.constant().map(|x| {
      x.into_iter().collect()
    });
    GateAddConstantT {
      type_id,
      out_id,
      in_id,
      constant,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateAddConstant::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAddConstant::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAddConstant::VT_IN_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn constant(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateAddConstant::VT_CONSTANT, None)}
  }
}

impl flatbuffers::Verifiable for GateAddConstant<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<u64>("in_id", Self::VT_IN_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("constant", Self::VT_CONSTANT, false)?
     .finish();
    Ok(())
  }
}
pub struct GateAddConstantArgs<'a> {
    pub type_id: u8,
    pub out_id: u64,
    pub in_id: u64,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GateAddConstantArgs<'a> {
  #[inline]
  fn default() -> Self {
    GateAddConstantArgs {
      type_id: 0,
      out_id: 0,
      in_id: 0,
      constant: None,
    }
  }
}

pub struct GateAddConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateAddConstant::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateAddConstant::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateAddConstant::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateAddConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAddConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateAddConstant<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateAddConstant");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("in_id", &self.in_id());
      ds.field("constant", &self.constant());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateAddConstantT {
  pub type_id: u8,
  pub out_id: u64,
  pub in_id: u64,
  pub constant: Option<Vec<u8>>,
}
impl Default for GateAddConstantT {
  fn default() -> Self {
    Self {
      type_id: 0,
      out_id: 0,
      in_id: 0,
      constant: None,
    }
  }
}
impl GateAddConstantT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateAddConstant<'b>> {
    let type_id = self.type_id;
    let out_id = self.out_id;
    let in_id = self.in_id;
    let constant = self.constant.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    GateAddConstant::create(_fbb, &GateAddConstantArgs{
      type_id,
      out_id,
      in_id,
      constant,
    })
  }
}
pub enum GateMulConstantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateMulConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMulConstant<'a> {
  type Inner = GateMulConstant<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateMulConstant<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_IN_ID: flatbuffers::VOffsetT = 8;
  pub const VT_CONSTANT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateMulConstant { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateMulConstantArgs<'args>
  ) -> flatbuffers::WIPOffset<GateMulConstant<'bldr>> {
    let mut builder = GateMulConstantBuilder::new(_fbb);
    builder.add_in_id(args.in_id);
    builder.add_out_id(args.out_id);
    if let Some(x) = args.constant { builder.add_constant(x); }
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateMulConstantT {
    let type_id = self.type_id();
    let out_id = self.out_id();
    let in_id = self.in_id();
    let constant = self.constant().map(|x| {
      x.into_iter().collect()
    });
    GateMulConstantT {
      type_id,
      out_id,
      in_id,
      constant,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateMulConstant::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMulConstant::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMulConstant::VT_IN_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn constant(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateMulConstant::VT_CONSTANT, None)}
  }
}

impl flatbuffers::Verifiable for GateMulConstant<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<u64>("in_id", Self::VT_IN_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("constant", Self::VT_CONSTANT, false)?
     .finish();
    Ok(())
  }
}
pub struct GateMulConstantArgs<'a> {
    pub type_id: u8,
    pub out_id: u64,
    pub in_id: u64,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GateMulConstantArgs<'a> {
  #[inline]
  fn default() -> Self {
    GateMulConstantArgs {
      type_id: 0,
      out_id: 0,
      in_id: 0,
      constant: None,
    }
  }
}

pub struct GateMulConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateMulConstant::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateMulConstant::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateMulConstant::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateMulConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMulConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateMulConstant<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateMulConstant");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("in_id", &self.in_id());
      ds.field("constant", &self.constant());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateMulConstantT {
  pub type_id: u8,
  pub out_id: u64,
  pub in_id: u64,
  pub constant: Option<Vec<u8>>,
}
impl Default for GateMulConstantT {
  fn default() -> Self {
    Self {
      type_id: 0,
      out_id: 0,
      in_id: 0,
      constant: None,
    }
  }
}
impl GateMulConstantT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateMulConstant<'b>> {
    let type_id = self.type_id;
    let out_id = self.out_id;
    let in_id = self.in_id;
    let constant = self.constant.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    GateMulConstant::create(_fbb, &GateMulConstantArgs{
      type_id,
      out_id,
      in_id,
      constant,
    })
  }
}
pub enum GatePublicOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatePublic<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatePublic<'a> {
  type Inner = GatePublic<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GatePublic<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatePublic { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatePublicArgs<'args>
  ) -> flatbuffers::WIPOffset<GatePublic<'bldr>> {
    let mut builder = GatePublicBuilder::new(_fbb);
    if let Some(x) = args.out_id { builder.add_out_id(x); }
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GatePublicT {
    let type_id = self.type_id();
    let out_id = self.out_id().map(|x| {
      x.unpack()
    });
    GatePublicT {
      type_id,
      out_id,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GatePublic::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> Option<&'a WireRange> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WireRange>(GatePublic::VT_OUT_ID, None)}
  }
}

impl flatbuffers::Verifiable for GatePublic<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<WireRange>("out_id", Self::VT_OUT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GatePublicArgs<'a> {
    pub type_id: u8,
    pub out_id: Option<&'a WireRange>,
}
impl<'a> Default for GatePublicArgs<'a> {
  #[inline]
  fn default() -> Self {
    GatePublicArgs {
      type_id: 0,
      out_id: None,
    }
  }
}

pub struct GatePublicBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatePublicBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GatePublic::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: &WireRange) {
    self.fbb_.push_slot_always::<&WireRange>(GatePublic::VT_OUT_ID, out_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatePublicBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatePublicBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatePublic<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatePublic<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatePublic");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GatePublicT {
  pub type_id: u8,
  pub out_id: Option<WireRangeT>,
}
impl Default for GatePublicT {
  fn default() -> Self {
    Self {
      type_id: 0,
      out_id: None,
    }
  }
}
impl GatePublicT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GatePublic<'b>> {
    let type_id = self.type_id;
    let out_id_tmp = self.out_id.as_ref().map(|x| x.pack());
    let out_id = out_id_tmp.as_ref();
    GatePublic::create(_fbb, &GatePublicArgs{
      type_id,
      out_id,
    })
  }
}
pub enum GatePrivateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatePrivate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatePrivate<'a> {
  type Inner = GatePrivate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GatePrivate<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatePrivate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatePrivateArgs<'args>
  ) -> flatbuffers::WIPOffset<GatePrivate<'bldr>> {
    let mut builder = GatePrivateBuilder::new(_fbb);
    if let Some(x) = args.out_id { builder.add_out_id(x); }
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GatePrivateT {
    let type_id = self.type_id();
    let out_id = self.out_id().map(|x| {
      x.unpack()
    });
    GatePrivateT {
      type_id,
      out_id,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GatePrivate::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> Option<&'a WireRange> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WireRange>(GatePrivate::VT_OUT_ID, None)}
  }
}

impl flatbuffers::Verifiable for GatePrivate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<WireRange>("out_id", Self::VT_OUT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GatePrivateArgs<'a> {
    pub type_id: u8,
    pub out_id: Option<&'a WireRange>,
}
impl<'a> Default for GatePrivateArgs<'a> {
  #[inline]
  fn default() -> Self {
    GatePrivateArgs {
      type_id: 0,
      out_id: None,
    }
  }
}

pub struct GatePrivateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatePrivateBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GatePrivate::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: &WireRange) {
    self.fbb_.push_slot_always::<&WireRange>(GatePrivate::VT_OUT_ID, out_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatePrivateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatePrivateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatePrivate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatePrivate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatePrivate");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GatePrivateT {
  pub type_id: u8,
  pub out_id: Option<WireRangeT>,
}
impl Default for GatePrivateT {
  fn default() -> Self {
    Self {
      type_id: 0,
      out_id: None,
    }
  }
}
impl GatePrivateT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GatePrivate<'b>> {
    let type_id = self.type_id;
    let out_id_tmp = self.out_id.as_ref().map(|x| x.pack());
    let out_id = out_id_tmp.as_ref();
    GatePrivate::create(_fbb, &GatePrivateArgs{
      type_id,
      out_id,
    })
  }
}
pub enum GateNewOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateNew<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateNew<'a> {
  type Inner = GateNew<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateNew<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_FIRST_ID: flatbuffers::VOffsetT = 6;
  pub const VT_LAST_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateNew { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateNewArgs
  ) -> flatbuffers::WIPOffset<GateNew<'bldr>> {
    let mut builder = GateNewBuilder::new(_fbb);
    builder.add_last_id(args.last_id);
    builder.add_first_id(args.first_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateNewT {
    let type_id = self.type_id();
    let first_id = self.first_id();
    let last_id = self.last_id();
    GateNewT {
      type_id,
      first_id,
      last_id,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateNew::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn first_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateNew::VT_FIRST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateNew::VT_LAST_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateNew<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("first_id", Self::VT_FIRST_ID, false)?
     .visit_field::<u64>("last_id", Self::VT_LAST_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateNewArgs {
    pub type_id: u8,
    pub first_id: u64,
    pub last_id: u64,
}
impl<'a> Default for GateNewArgs {
  #[inline]
  fn default() -> Self {
    GateNewArgs {
      type_id: 0,
      first_id: 0,
      last_id: 0,
    }
  }
}

pub struct GateNewBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateNewBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateNew::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_first_id(&mut self, first_id: u64) {
    self.fbb_.push_slot::<u64>(GateNew::VT_FIRST_ID, first_id, 0);
  }
  #[inline]
  pub fn add_last_id(&mut self, last_id: u64) {
    self.fbb_.push_slot::<u64>(GateNew::VT_LAST_ID, last_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateNewBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateNewBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateNew<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateNew<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateNew");
      ds.field("type_id", &self.type_id());
      ds.field("first_id", &self.first_id());
      ds.field("last_id", &self.last_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateNewT {
  pub type_id: u8,
  pub first_id: u64,
  pub last_id: u64,
}
impl Default for GateNewT {
  fn default() -> Self {
    Self {
      type_id: 0,
      first_id: 0,
      last_id: 0,
    }
  }
}
impl GateNewT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateNew<'b>> {
    let type_id = self.type_id;
    let first_id = self.first_id;
    let last_id = self.last_id;
    GateNew::create(_fbb, &GateNewArgs{
      type_id,
      first_id,
      last_id,
    })
  }
}
pub enum GateDeleteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateDelete<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateDelete<'a> {
  type Inner = GateDelete<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateDelete<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_FIRST_ID: flatbuffers::VOffsetT = 6;
  pub const VT_LAST_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateDelete { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateDeleteArgs
  ) -> flatbuffers::WIPOffset<GateDelete<'bldr>> {
    let mut builder = GateDeleteBuilder::new(_fbb);
    builder.add_last_id(args.last_id);
    builder.add_first_id(args.first_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateDeleteT {
    let type_id = self.type_id();
    let first_id = self.first_id();
    let last_id = self.last_id();
    GateDeleteT {
      type_id,
      first_id,
      last_id,
    }
  }

  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateDelete::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn first_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateDelete::VT_FIRST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateDelete::VT_LAST_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateDelete<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("first_id", Self::VT_FIRST_ID, false)?
     .visit_field::<u64>("last_id", Self::VT_LAST_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateDeleteArgs {
    pub type_id: u8,
    pub first_id: u64,
    pub last_id: u64,
}
impl<'a> Default for GateDeleteArgs {
  #[inline]
  fn default() -> Self {
    GateDeleteArgs {
      type_id: 0,
      first_id: 0,
      last_id: 0,
    }
  }
}

pub struct GateDeleteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateDeleteBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateDelete::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_first_id(&mut self, first_id: u64) {
    self.fbb_.push_slot::<u64>(GateDelete::VT_FIRST_ID, first_id, 0);
  }
  #[inline]
  pub fn add_last_id(&mut self, last_id: u64) {
    self.fbb_.push_slot::<u64>(GateDelete::VT_LAST_ID, last_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateDeleteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateDeleteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateDelete<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateDelete<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateDelete");
      ds.field("type_id", &self.type_id());
      ds.field("first_id", &self.first_id());
      ds.field("last_id", &self.last_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateDeleteT {
  pub type_id: u8,
  pub first_id: u64,
  pub last_id: u64,
}
impl Default for GateDeleteT {
  fn default() -> Self {
    Self {
      type_id: 0,
      first_id: 0,
      last_id: 0,
    }
  }
}
impl GateDeleteT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateDelete<'b>> {
    let type_id = self.type_id;
    let first_id = self.first_id;
    let last_id = self.last_id;
    GateDelete::create(_fbb, &GateDeleteArgs{
      type_id,
      first_id,
      last_id,
    })
  }
}
pub enum GateConvertOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateConvert<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateConvert<'a> {
  type Inner = GateConvert<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateConvert<'a> {
  pub const VT_OUT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_FIRST_ID: flatbuffers::VOffsetT = 6;
  pub const VT_OUT_LAST_ID: flatbuffers::VOffsetT = 8;
  pub const VT_IN_TYPE_ID: flatbuffers::VOffsetT = 10;
  pub const VT_IN_FIRST_ID: flatbuffers::VOffsetT = 12;
  pub const VT_IN_LAST_ID: flatbuffers::VOffsetT = 14;
  pub const VT_MODULUS: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateConvert { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateConvertArgs
  ) -> flatbuffers::WIPOffset<GateConvert<'bldr>> {
    let mut builder = GateConvertBuilder::new(_fbb);
    builder.add_in_last_id(args.in_last_id);
    builder.add_in_first_id(args.in_first_id);
    builder.add_out_last_id(args.out_last_id);
    builder.add_out_first_id(args.out_first_id);
    builder.add_modulus(args.modulus);
    builder.add_in_type_id(args.in_type_id);
    builder.add_out_type_id(args.out_type_id);
    builder.finish()
  }

  pub fn unpack(&self) -> GateConvertT {
    let out_type_id = self.out_type_id();
    let out_first_id = self.out_first_id();
    let out_last_id = self.out_last_id();
    let in_type_id = self.in_type_id();
    let in_first_id = self.in_first_id();
    let in_last_id = self.in_last_id();
    let modulus = self.modulus();
    GateConvertT {
      out_type_id,
      out_first_id,
      out_last_id,
      in_type_id,
      in_first_id,
      in_last_id,
      modulus,
    }
  }

  #[inline]
  pub fn out_type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateConvert::VT_OUT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_first_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConvert::VT_OUT_FIRST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_last_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConvert::VT_OUT_LAST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateConvert::VT_IN_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_first_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConvert::VT_IN_FIRST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_last_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConvert::VT_IN_LAST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn modulus(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GateConvert::VT_MODULUS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateConvert<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("out_type_id", Self::VT_OUT_TYPE_ID, false)?
     .visit_field::<u64>("out_first_id", Self::VT_OUT_FIRST_ID, false)?
     .visit_field::<u64>("out_last_id", Self::VT_OUT_LAST_ID, false)?
     .visit_field::<u8>("in_type_id", Self::VT_IN_TYPE_ID, false)?
     .visit_field::<u64>("in_first_id", Self::VT_IN_FIRST_ID, false)?
     .visit_field::<u64>("in_last_id", Self::VT_IN_LAST_ID, false)?
     .visit_field::<bool>("modulus", Self::VT_MODULUS, false)?
     .finish();
    Ok(())
  }
}
pub struct GateConvertArgs {
    pub out_type_id: u8,
    pub out_first_id: u64,
    pub out_last_id: u64,
    pub in_type_id: u8,
    pub in_first_id: u64,
    pub in_last_id: u64,
    pub modulus: bool,
}
impl<'a> Default for GateConvertArgs {
  #[inline]
  fn default() -> Self {
    GateConvertArgs {
      out_type_id: 0,
      out_first_id: 0,
      out_last_id: 0,
      in_type_id: 0,
      in_first_id: 0,
      in_last_id: 0,
      modulus: false,
    }
  }
}

pub struct GateConvertBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateConvertBuilder<'a, 'b> {
  #[inline]
  pub fn add_out_type_id(&mut self, out_type_id: u8) {
    self.fbb_.push_slot::<u8>(GateConvert::VT_OUT_TYPE_ID, out_type_id, 0);
  }
  #[inline]
  pub fn add_out_first_id(&mut self, out_first_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_OUT_FIRST_ID, out_first_id, 0);
  }
  #[inline]
  pub fn add_out_last_id(&mut self, out_last_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_OUT_LAST_ID, out_last_id, 0);
  }
  #[inline]
  pub fn add_in_type_id(&mut self, in_type_id: u8) {
    self.fbb_.push_slot::<u8>(GateConvert::VT_IN_TYPE_ID, in_type_id, 0);
  }
  #[inline]
  pub fn add_in_first_id(&mut self, in_first_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_IN_FIRST_ID, in_first_id, 0);
  }
  #[inline]
  pub fn add_in_last_id(&mut self, in_last_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_IN_LAST_ID, in_last_id, 0);
  }
  #[inline]
  pub fn add_modulus(&mut self, modulus: bool) {
    self.fbb_.push_slot::<bool>(GateConvert::VT_MODULUS, modulus, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateConvertBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateConvertBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateConvert<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateConvert<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateConvert");
      ds.field("out_type_id", &self.out_type_id());
      ds.field("out_first_id", &self.out_first_id());
      ds.field("out_last_id", &self.out_last_id());
      ds.field("in_type_id", &self.in_type_id());
      ds.field("in_first_id", &self.in_first_id());
      ds.field("in_last_id", &self.in_last_id());
      ds.field("modulus", &self.modulus());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateConvertT {
  pub out_type_id: u8,
  pub out_first_id: u64,
  pub out_last_id: u64,
  pub in_type_id: u8,
  pub in_first_id: u64,
  pub in_last_id: u64,
  pub modulus: bool,
}
impl Default for GateConvertT {
  fn default() -> Self {
    Self {
      out_type_id: 0,
      out_first_id: 0,
      out_last_id: 0,
      in_type_id: 0,
      in_first_id: 0,
      in_last_id: 0,
      modulus: false,
    }
  }
}
impl GateConvertT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateConvert<'b>> {
    let out_type_id = self.out_type_id;
    let out_first_id = self.out_first_id;
    let out_last_id = self.out_last_id;
    let in_type_id = self.in_type_id;
    let in_first_id = self.in_first_id;
    let in_last_id = self.in_last_id;
    let modulus = self.modulus;
    GateConvert::create(_fbb, &GateConvertArgs{
      out_type_id,
      out_first_id,
      out_last_id,
      in_type_id,
      in_first_id,
      in_last_id,
      modulus,
    })
  }
}
pub enum GatesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Gates<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Gates<'a> {
  type Inner = Gates<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Gates<'a> {
  pub const VT_GATES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Gates { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatesArgs<'args>
  ) -> flatbuffers::WIPOffset<Gates<'bldr>> {
    let mut builder = GatesBuilder::new(_fbb);
    if let Some(x) = args.gates { builder.add_gates(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GatesT {
    let gates = self.gates().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    GatesT {
      gates,
    }
  }

  #[inline]
  pub fn gates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Gate<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Gate>>>>(Gates::VT_GATES, None)}
  }
}

impl flatbuffers::Verifiable for Gates<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Gate>>>>("gates", Self::VT_GATES, false)?
     .finish();
    Ok(())
  }
}
pub struct GatesArgs<'a> {
    pub gates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Gate<'a>>>>>,
}
impl<'a> Default for GatesArgs<'a> {
  #[inline]
  fn default() -> Self {
    GatesArgs {
      gates: None,
    }
  }
}

pub struct GatesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatesBuilder<'a, 'b> {
  #[inline]
  pub fn add_gates(&mut self, gates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Gate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Gates::VT_GATES, gates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Gates<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Gates<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Gates");
      ds.field("gates", &self.gates());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GatesT {
  pub gates: Option<Vec<GateT>>,
}
impl Default for GatesT {
  fn default() -> Self {
    Self {
      gates: None,
    }
  }
}
impl GatesT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Gates<'b>> {
    let gates = self.gates.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Gates::create(_fbb, &GatesArgs{
      gates,
    })
  }
}
pub enum PluginBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PluginBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginBody<'a> {
  type Inner = PluginBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PluginBody<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OPERATION: flatbuffers::VOffsetT = 6;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 8;
  pub const VT_PUBLIC_COUNT: flatbuffers::VOffsetT = 10;
  pub const VT_PRIVATE_COUNT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PluginBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PluginBodyArgs<'args>
  ) -> flatbuffers::WIPOffset<PluginBody<'bldr>> {
    let mut builder = PluginBodyBuilder::new(_fbb);
    if let Some(x) = args.private_count { builder.add_private_count(x); }
    if let Some(x) = args.public_count { builder.add_public_count(x); }
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.operation { builder.add_operation(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PluginBodyT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let operation = self.operation().map(|x| {
      x.to_string()
    });
    let params = self.params().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let public_count = self.public_count().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let private_count = self.private_count().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    PluginBodyT {
      name,
      operation,
      params,
      public_count,
      private_count,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginBody::VT_NAME, None)}
  }
  #[inline]
  pub fn operation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginBody::VT_OPERATION, None)}
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PluginBody::VT_PARAMS, None)}
  }
  #[inline]
  pub fn public_count(&self) -> Option<flatbuffers::Vector<'a, Count>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Count>>>(PluginBody::VT_PUBLIC_COUNT, None)}
  }
  #[inline]
  pub fn private_count(&self) -> Option<flatbuffers::Vector<'a, Count>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Count>>>(PluginBody::VT_PRIVATE_COUNT, None)}
  }
}

impl flatbuffers::Verifiable for PluginBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operation", Self::VT_OPERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("params", Self::VT_PARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Count>>>("public_count", Self::VT_PUBLIC_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Count>>>("private_count", Self::VT_PRIVATE_COUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct PluginBodyArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub public_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Count>>>,
    pub private_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Count>>>,
}
impl<'a> Default for PluginBodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    PluginBodyArgs {
      name: None,
      operation: None,
      params: None,
      public_count: None,
      private_count: None,
    }
  }
}

pub struct PluginBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PluginBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_NAME, name);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_OPERATION, operation);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_PARAMS, params);
  }
  #[inline]
  pub fn add_public_count(&mut self, public_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_PUBLIC_COUNT, public_count);
  }
  #[inline]
  pub fn add_private_count(&mut self, private_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_PRIVATE_COUNT, private_count);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PluginBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PluginBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PluginBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PluginBody");
      ds.field("name", &self.name());
      ds.field("operation", &self.operation());
      ds.field("params", &self.params());
      ds.field("public_count", &self.public_count());
      ds.field("private_count", &self.private_count());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PluginBodyT {
  pub name: Option<String>,
  pub operation: Option<String>,
  pub params: Option<Vec<String>>,
  pub public_count: Option<Vec<CountT>>,
  pub private_count: Option<Vec<CountT>>,
}
impl Default for PluginBodyT {
  fn default() -> Self {
    Self {
      name: None,
      operation: None,
      params: None,
      public_count: None,
      private_count: None,
    }
  }
}
impl PluginBodyT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PluginBody<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let operation = self.operation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let params = self.params.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let public_count = self.public_count.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let private_count = self.private_count.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    PluginBody::create(_fbb, &PluginBodyArgs{
      name,
      operation,
      params,
      public_count,
      private_count,
    })
  }
}
pub enum FunctionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Function<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Function<'a> {
  type Inner = Function<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Function<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OUTPUT_COUNT: flatbuffers::VOffsetT = 6;
  pub const VT_INPUT_COUNT: flatbuffers::VOffsetT = 8;
  pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_BODY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Function { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FunctionArgs<'args>
  ) -> flatbuffers::WIPOffset<Function<'bldr>> {
    let mut builder = FunctionBuilder::new(_fbb);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.input_count { builder.add_input_count(x); }
    if let Some(x) = args.output_count { builder.add_output_count(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_body_type(args.body_type);
    builder.finish()
  }

  pub fn unpack(&self) -> FunctionT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let output_count = self.output_count().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let input_count = self.input_count().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let body = match self.body_type() {
      FunctionBody::NONE => FunctionBodyT::NONE,
      FunctionBody::Gates => FunctionBodyT::Gates(Box::new(
        self.body_as_gates()
            .expect("Invalid union table, expected `FunctionBody::Gates`.")
            .unpack()
      )),
      FunctionBody::PluginBody => FunctionBodyT::PluginBody(Box::new(
        self.body_as_plugin_body()
            .expect("Invalid union table, expected `FunctionBody::PluginBody`.")
            .unpack()
      )),
      _ => FunctionBodyT::NONE,
    };
    FunctionT {
      name,
      output_count,
      input_count,
      body,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Function::VT_NAME, None)}
  }
  #[inline]
  pub fn output_count(&self) -> Option<flatbuffers::Vector<'a, Count>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Count>>>(Function::VT_OUTPUT_COUNT, None)}
  }
  #[inline]
  pub fn input_count(&self) -> Option<flatbuffers::Vector<'a, Count>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Count>>>(Function::VT_INPUT_COUNT, None)}
  }
  #[inline]
  pub fn body_type(&self) -> FunctionBody {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FunctionBody>(Function::VT_BODY_TYPE, Some(FunctionBody::NONE)).unwrap()}
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Function::VT_BODY, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_gates(&self) -> Option<Gates<'a>> {
    if self.body_type() == FunctionBody::Gates {
      self.body().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Gates::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_plugin_body(&self) -> Option<PluginBody<'a>> {
    if self.body_type() == FunctionBody::PluginBody {
      self.body().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PluginBody::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Function<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Count>>>("output_count", Self::VT_OUTPUT_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Count>>>("input_count", Self::VT_INPUT_COUNT, false)?
     .visit_union::<FunctionBody, _>("body_type", Self::VT_BODY_TYPE, "body", Self::VT_BODY, false, |key, v, pos| {
        match key {
          FunctionBody::Gates => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Gates>>("FunctionBody::Gates", pos),
          FunctionBody::PluginBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PluginBody>>("FunctionBody::PluginBody", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct FunctionArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub output_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Count>>>,
    pub input_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Count>>>,
    pub body_type: FunctionBody,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FunctionArgs<'a> {
  #[inline]
  fn default() -> Self {
    FunctionArgs {
      name: None,
      output_count: None,
      input_count: None,
      body_type: FunctionBody::NONE,
      body: None,
    }
  }
}

pub struct FunctionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FunctionBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_NAME, name);
  }
  #[inline]
  pub fn add_output_count(&mut self, output_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_OUTPUT_COUNT, output_count);
  }
  #[inline]
  pub fn add_input_count(&mut self, input_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_INPUT_COUNT, input_count);
  }
  #[inline]
  pub fn add_body_type(&mut self, body_type: FunctionBody) {
    self.fbb_.push_slot::<FunctionBody>(Function::VT_BODY_TYPE, body_type, FunctionBody::NONE);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunctionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FunctionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Function<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Function<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Function");
      ds.field("name", &self.name());
      ds.field("output_count", &self.output_count());
      ds.field("input_count", &self.input_count());
      ds.field("body_type", &self.body_type());
      match self.body_type() {
        FunctionBody::Gates => {
          if let Some(x) = self.body_as_gates() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        FunctionBody::PluginBody => {
          if let Some(x) = self.body_as_plugin_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("body", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FunctionT {
  pub name: Option<String>,
  pub output_count: Option<Vec<CountT>>,
  pub input_count: Option<Vec<CountT>>,
  pub body: FunctionBodyT,
}
impl Default for FunctionT {
  fn default() -> Self {
    Self {
      name: None,
      output_count: None,
      input_count: None,
      body: FunctionBodyT::NONE,
    }
  }
}
impl FunctionT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Function<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let output_count = self.output_count.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let input_count = self.input_count.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let body_type = self.body.function_body_type();
    let body = self.body.pack(_fbb);
    Function::create(_fbb, &FunctionArgs{
      name,
      output_count,
      input_count,
      body_type,
      body,
    })
  }
}
pub enum GateCallOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateCall<'a> {
  type Inner = GateCall<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateCall<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_IDS: flatbuffers::VOffsetT = 6;
  pub const VT_IN_IDS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateCall { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateCallArgs<'args>
  ) -> flatbuffers::WIPOffset<GateCall<'bldr>> {
    let mut builder = GateCallBuilder::new(_fbb);
    if let Some(x) = args.in_ids { builder.add_in_ids(x); }
    if let Some(x) = args.out_ids { builder.add_out_ids(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GateCallT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let out_ids = self.out_ids().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let in_ids = self.in_ids().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    GateCallT {
      name,
      out_ids,
      in_ids,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GateCall::VT_NAME, None)}
  }
  #[inline]
  pub fn out_ids(&self) -> Option<flatbuffers::Vector<'a, WireRange>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, WireRange>>>(GateCall::VT_OUT_IDS, None)}
  }
  #[inline]
  pub fn in_ids(&self) -> Option<flatbuffers::Vector<'a, WireRange>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, WireRange>>>(GateCall::VT_IN_IDS, None)}
  }
}

impl flatbuffers::Verifiable for GateCall<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, WireRange>>>("out_ids", Self::VT_OUT_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, WireRange>>>("in_ids", Self::VT_IN_IDS, false)?
     .finish();
    Ok(())
  }
}
pub struct GateCallArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub out_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, WireRange>>>,
    pub in_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, WireRange>>>,
}
impl<'a> Default for GateCallArgs<'a> {
  #[inline]
  fn default() -> Self {
    GateCallArgs {
      name: None,
      out_ids: None,
      in_ids: None,
    }
  }
}

pub struct GateCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_NAME, name);
  }
  #[inline]
  pub fn add_out_ids(&mut self, out_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , WireRange>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_OUT_IDS, out_ids);
  }
  #[inline]
  pub fn add_in_ids(&mut self, in_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , WireRange>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_IN_IDS, in_ids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateCall<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateCall");
      ds.field("name", &self.name());
      ds.field("out_ids", &self.out_ids());
      ds.field("in_ids", &self.in_ids());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateCallT {
  pub name: Option<String>,
  pub out_ids: Option<Vec<WireRangeT>>,
  pub in_ids: Option<Vec<WireRangeT>>,
}
impl Default for GateCallT {
  fn default() -> Self {
    Self {
      name: None,
      out_ids: None,
      in_ids: None,
    }
  }
}
impl GateCallT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GateCall<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let out_ids = self.out_ids.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let in_ids = self.in_ids.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    GateCall::create(_fbb, &GateCallArgs{
      name,
      out_ids,
      in_ids,
    })
  }
}
pub enum GateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Gate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Gate<'a> {
  type Inner = Gate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Gate<'a> {
  pub const VT_GATE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_GATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Gate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateArgs
  ) -> flatbuffers::WIPOffset<Gate<'bldr>> {
    let mut builder = GateBuilder::new(_fbb);
    if let Some(x) = args.gate { builder.add_gate(x); }
    builder.add_gate_type(args.gate_type);
    builder.finish()
  }

  pub fn unpack(&self) -> GateT {
    let gate = match self.gate_type() {
      GateSet::NONE => GateSetT::NONE,
      GateSet::GateConstant => GateSetT::GateConstant(Box::new(
        self.gate_as_gate_constant()
            .expect("Invalid union table, expected `GateSet::GateConstant`.")
            .unpack()
      )),
      GateSet::GateAssertZero => GateSetT::GateAssertZero(Box::new(
        self.gate_as_gate_assert_zero()
            .expect("Invalid union table, expected `GateSet::GateAssertZero`.")
            .unpack()
      )),
      GateSet::GateCopy => GateSetT::GateCopy(Box::new(
        self.gate_as_gate_copy()
            .expect("Invalid union table, expected `GateSet::GateCopy`.")
            .unpack()
      )),
      GateSet::GateAdd => GateSetT::GateAdd(Box::new(
        self.gate_as_gate_add()
            .expect("Invalid union table, expected `GateSet::GateAdd`.")
            .unpack()
      )),
      GateSet::GateMul => GateSetT::GateMul(Box::new(
        self.gate_as_gate_mul()
            .expect("Invalid union table, expected `GateSet::GateMul`.")
            .unpack()
      )),
      GateSet::GateAddConstant => GateSetT::GateAddConstant(Box::new(
        self.gate_as_gate_add_constant()
            .expect("Invalid union table, expected `GateSet::GateAddConstant`.")
            .unpack()
      )),
      GateSet::GateMulConstant => GateSetT::GateMulConstant(Box::new(
        self.gate_as_gate_mul_constant()
            .expect("Invalid union table, expected `GateSet::GateMulConstant`.")
            .unpack()
      )),
      GateSet::GatePublic => GateSetT::GatePublic(Box::new(
        self.gate_as_gate_public()
            .expect("Invalid union table, expected `GateSet::GatePublic`.")
            .unpack()
      )),
      GateSet::GatePrivate => GateSetT::GatePrivate(Box::new(
        self.gate_as_gate_private()
            .expect("Invalid union table, expected `GateSet::GatePrivate`.")
            .unpack()
      )),
      GateSet::GateNew => GateSetT::GateNew(Box::new(
        self.gate_as_gate_new()
            .expect("Invalid union table, expected `GateSet::GateNew`.")
            .unpack()
      )),
      GateSet::GateDelete => GateSetT::GateDelete(Box::new(
        self.gate_as_gate_delete()
            .expect("Invalid union table, expected `GateSet::GateDelete`.")
            .unpack()
      )),
      GateSet::GateConvert => GateSetT::GateConvert(Box::new(
        self.gate_as_gate_convert()
            .expect("Invalid union table, expected `GateSet::GateConvert`.")
            .unpack()
      )),
      GateSet::GateCall => GateSetT::GateCall(Box::new(
        self.gate_as_gate_call()
            .expect("Invalid union table, expected `GateSet::GateCall`.")
            .unpack()
      )),
      _ => GateSetT::NONE,
    };
    GateT {
      gate,
    }
  }

  #[inline]
  pub fn gate_type(&self) -> GateSet {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GateSet>(Gate::VT_GATE_TYPE, Some(GateSet::NONE)).unwrap()}
  }
  #[inline]
  pub fn gate(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Gate::VT_GATE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_constant(&self) -> Option<GateConstant<'a>> {
    if self.gate_type() == GateSet::GateConstant {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateConstant::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_assert_zero(&self) -> Option<GateAssertZero<'a>> {
    if self.gate_type() == GateSet::GateAssertZero {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateAssertZero::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_copy(&self) -> Option<GateCopy<'a>> {
    if self.gate_type() == GateSet::GateCopy {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateCopy::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_add(&self) -> Option<GateAdd<'a>> {
    if self.gate_type() == GateSet::GateAdd {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateAdd::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_mul(&self) -> Option<GateMul<'a>> {
    if self.gate_type() == GateSet::GateMul {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateMul::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_add_constant(&self) -> Option<GateAddConstant<'a>> {
    if self.gate_type() == GateSet::GateAddConstant {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateAddConstant::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_mul_constant(&self) -> Option<GateMulConstant<'a>> {
    if self.gate_type() == GateSet::GateMulConstant {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateMulConstant::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_public(&self) -> Option<GatePublic<'a>> {
    if self.gate_type() == GateSet::GatePublic {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GatePublic::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_private(&self) -> Option<GatePrivate<'a>> {
    if self.gate_type() == GateSet::GatePrivate {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GatePrivate::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_new(&self) -> Option<GateNew<'a>> {
    if self.gate_type() == GateSet::GateNew {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateNew::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_delete(&self) -> Option<GateDelete<'a>> {
    if self.gate_type() == GateSet::GateDelete {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateDelete::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_convert(&self) -> Option<GateConvert<'a>> {
    if self.gate_type() == GateSet::GateConvert {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateConvert::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_call(&self) -> Option<GateCall<'a>> {
    if self.gate_type() == GateSet::GateCall {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateCall::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Gate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<GateSet, _>("gate_type", Self::VT_GATE_TYPE, "gate", Self::VT_GATE, false, |key, v, pos| {
        match key {
          GateSet::GateConstant => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateConstant>>("GateSet::GateConstant", pos),
          GateSet::GateAssertZero => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateAssertZero>>("GateSet::GateAssertZero", pos),
          GateSet::GateCopy => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateCopy>>("GateSet::GateCopy", pos),
          GateSet::GateAdd => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateAdd>>("GateSet::GateAdd", pos),
          GateSet::GateMul => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateMul>>("GateSet::GateMul", pos),
          GateSet::GateAddConstant => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateAddConstant>>("GateSet::GateAddConstant", pos),
          GateSet::GateMulConstant => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateMulConstant>>("GateSet::GateMulConstant", pos),
          GateSet::GatePublic => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatePublic>>("GateSet::GatePublic", pos),
          GateSet::GatePrivate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatePrivate>>("GateSet::GatePrivate", pos),
          GateSet::GateNew => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateNew>>("GateSet::GateNew", pos),
          GateSet::GateDelete => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateDelete>>("GateSet::GateDelete", pos),
          GateSet::GateConvert => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateConvert>>("GateSet::GateConvert", pos),
          GateSet::GateCall => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateCall>>("GateSet::GateCall", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct GateArgs {
    pub gate_type: GateSet,
    pub gate: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for GateArgs {
  #[inline]
  fn default() -> Self {
    GateArgs {
      gate_type: GateSet::NONE,
      gate: None,
    }
  }
}

pub struct GateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateBuilder<'a, 'b> {
  #[inline]
  pub fn add_gate_type(&mut self, gate_type: GateSet) {
    self.fbb_.push_slot::<GateSet>(Gate::VT_GATE_TYPE, gate_type, GateSet::NONE);
  }
  #[inline]
  pub fn add_gate(&mut self, gate: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Gate::VT_GATE, gate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Gate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Gate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Gate");
      ds.field("gate_type", &self.gate_type());
      match self.gate_type() {
        GateSet::GateConstant => {
          if let Some(x) = self.gate_as_gate_constant() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateAssertZero => {
          if let Some(x) = self.gate_as_gate_assert_zero() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateCopy => {
          if let Some(x) = self.gate_as_gate_copy() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateAdd => {
          if let Some(x) = self.gate_as_gate_add() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateMul => {
          if let Some(x) = self.gate_as_gate_mul() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateAddConstant => {
          if let Some(x) = self.gate_as_gate_add_constant() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateMulConstant => {
          if let Some(x) = self.gate_as_gate_mul_constant() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GatePublic => {
          if let Some(x) = self.gate_as_gate_public() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GatePrivate => {
          if let Some(x) = self.gate_as_gate_private() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateNew => {
          if let Some(x) = self.gate_as_gate_new() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateDelete => {
          if let Some(x) = self.gate_as_gate_delete() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateConvert => {
          if let Some(x) = self.gate_as_gate_convert() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateCall => {
          if let Some(x) = self.gate_as_gate_call() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("gate", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GateT {
  pub gate: GateSetT,
}
impl Default for GateT {
  fn default() -> Self {
    Self {
      gate: GateSetT::NONE,
    }
  }
}
impl GateT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Gate<'b>> {
    let gate_type = self.gate.gate_set_type();
    let gate = self.gate.pack(_fbb);
    Gate::create(_fbb, &GateArgs{
      gate_type,
      gate,
    })
  }
}
pub enum RootOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Root<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Root<'a> {
  type Inner = Root<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Root<'a> {
  pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Root { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RootArgs
  ) -> flatbuffers::WIPOffset<Root<'bldr>> {
    let mut builder = RootBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.add_message_type(args.message_type);
    builder.finish()
  }

  pub fn unpack(&self) -> RootT {
    let message = match self.message_type() {
      Message::NONE => MessageT::NONE,
      Message::Relation => MessageT::Relation(Box::new(
        self.message_as_relation()
            .expect("Invalid union table, expected `Message::Relation`.")
            .unpack()
      )),
      Message::PublicInputs => MessageT::PublicInputs(Box::new(
        self.message_as_public_inputs()
            .expect("Invalid union table, expected `Message::PublicInputs`.")
            .unpack()
      )),
      Message::PrivateInputs => MessageT::PrivateInputs(Box::new(
        self.message_as_private_inputs()
            .expect("Invalid union table, expected `Message::PrivateInputs`.")
            .unpack()
      )),
      _ => MessageT::NONE,
    };
    RootT {
      message,
    }
  }

  #[inline]
  pub fn message_type(&self) -> Message {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Message>(Root::VT_MESSAGE_TYPE, Some(Message::NONE)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Root::VT_MESSAGE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_relation(&self) -> Option<Relation<'a>> {
    if self.message_type() == Message::Relation {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Relation::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_public_inputs(&self) -> Option<PublicInputs<'a>> {
    if self.message_type() == Message::PublicInputs {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PublicInputs::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_private_inputs(&self) -> Option<PrivateInputs<'a>> {
    if self.message_type() == Message::PrivateInputs {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PrivateInputs::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Root<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Message, _>("message_type", Self::VT_MESSAGE_TYPE, "message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          Message::Relation => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Relation>>("Message::Relation", pos),
          Message::PublicInputs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PublicInputs>>("Message::PublicInputs", pos),
          Message::PrivateInputs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PrivateInputs>>("Message::PrivateInputs", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RootArgs {
    pub message_type: Message,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RootArgs {
  #[inline]
  fn default() -> Self {
    RootArgs {
      message_type: Message::NONE,
      message: None,
    }
  }
}

pub struct RootBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RootBuilder<'a, 'b> {
  #[inline]
  pub fn add_message_type(&mut self, message_type: Message) {
    self.fbb_.push_slot::<Message>(Root::VT_MESSAGE_TYPE, message_type, Message::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Root::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RootBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RootBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Root<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Root<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Root");
      ds.field("message_type", &self.message_type());
      match self.message_type() {
        Message::Relation => {
          if let Some(x) = self.message_as_relation() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::PublicInputs => {
          if let Some(x) = self.message_as_public_inputs() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::PrivateInputs => {
          if let Some(x) = self.message_as_private_inputs() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("message", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RootT {
  pub message: MessageT,
}
impl Default for RootT {
  fn default() -> Self {
    Self {
      message: MessageT::NONE,
    }
  }
}
impl RootT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Root<'b>> {
    let message_type = self.message.message_type();
    let message = self.message.pack(_fbb);
    Root::create(_fbb, &RootArgs{
      message_type,
      message,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Root`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_root_unchecked`.
pub fn root_as_root(buf: &[u8]) -> Result<Root, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Root>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Root` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_root_unchecked`.
pub fn size_prefixed_root_as_root(buf: &[u8]) -> Result<Root, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Root>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Root` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_root_unchecked`.
pub fn root_as_root_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Root<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Root<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Root` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_root_unchecked`.
pub fn size_prefixed_root_as_root_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Root<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Root<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Root and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Root`.
pub unsafe fn root_as_root_unchecked(buf: &[u8]) -> Root {
  flatbuffers::root_unchecked::<Root>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Root and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Root`.
pub unsafe fn size_prefixed_root_as_root_unchecked(buf: &[u8]) -> Root {
  flatbuffers::size_prefixed_root_unchecked::<Root>(buf)
}
pub const ROOT_IDENTIFIER: &str = "siev";

#[inline]
pub fn root_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, false)
}

#[inline]
pub fn root_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, true)
}

pub const ROOT_EXTENSION: &str = "sieve";

#[inline]
pub fn finish_root_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish(root, Some(ROOT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_root_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish_size_prefixed(root, Some(ROOT_IDENTIFIER));
}
}  // pub mod sieve_ir

