// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod sieve_ir {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Message {
  NONE = 0,
  Relation = 1,
  PublicInputs = 2,
  PrivateInputs = 3,

}

pub const ENUM_MIN_MESSAGE: u8 = 0;
pub const ENUM_MAX_MESSAGE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Message {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Message>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE:[Message; 4] = [
  Message::NONE,
  Message::Relation,
  Message::PublicInputs,
  Message::PrivateInputs
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_MESSAGE:[&'static str; 4] = [
    "NONE",
    "Relation",
    "PublicInputs",
    "PrivateInputs"
];

pub fn enum_name_message(e: Message) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_MESSAGE[index as usize]
}

pub struct MessageUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FunctionBody {
  NONE = 0,
  Gates = 1,
  PluginBody = 2,

}

pub const ENUM_MIN_FUNCTION_BODY: u8 = 0;
pub const ENUM_MAX_FUNCTION_BODY: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for FunctionBody {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FunctionBody {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FunctionBody;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FunctionBody;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FunctionBody {
    type Output = FunctionBody;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FunctionBody>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FUNCTION_BODY:[FunctionBody; 3] = [
  FunctionBody::NONE,
  FunctionBody::Gates,
  FunctionBody::PluginBody
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FUNCTION_BODY:[&'static str; 3] = [
    "NONE",
    "Gates",
    "PluginBody"
];

pub fn enum_name_function_body(e: FunctionBody) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FUNCTION_BODY[index as usize]
}

pub struct FunctionBodyUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum DirectiveSet {
  NONE = 0,
  GateConstant = 1,
  GateAssertZero = 2,
  GateCopy = 3,
  GateAdd = 4,
  GateMul = 5,
  GateAddConstant = 6,
  GateMulConstant = 7,
  GatePublicInput = 8,
  GatePrivateInput = 9,
  GateNew = 10,
  GateDelete = 11,
  GateConvert = 12,
  GateCall = 13,

}

pub const ENUM_MIN_DIRECTIVE_SET: u8 = 0;
pub const ENUM_MAX_DIRECTIVE_SET: u8 = 13;

impl<'a> flatbuffers::Follow<'a> for DirectiveSet {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for DirectiveSet {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const DirectiveSet;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const DirectiveSet;
    unsafe { *p }
  }
}

impl flatbuffers::Push for DirectiveSet {
    type Output = DirectiveSet;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<DirectiveSet>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIRECTIVE_SET:[DirectiveSet; 14] = [
  DirectiveSet::NONE,
  DirectiveSet::GateConstant,
  DirectiveSet::GateAssertZero,
  DirectiveSet::GateCopy,
  DirectiveSet::GateAdd,
  DirectiveSet::GateMul,
  DirectiveSet::GateAddConstant,
  DirectiveSet::GateMulConstant,
  DirectiveSet::GatePublicInput,
  DirectiveSet::GatePrivateInput,
  DirectiveSet::GateNew,
  DirectiveSet::GateDelete,
  DirectiveSet::GateConvert,
  DirectiveSet::GateCall
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_DIRECTIVE_SET:[&'static str; 14] = [
    "NONE",
    "GateConstant",
    "GateAssertZero",
    "GateCopy",
    "GateAdd",
    "GateMul",
    "GateAddConstant",
    "GateMulConstant",
    "GatePublicInput",
    "GatePrivateInput",
    "GateNew",
    "GateDelete",
    "GateConvert",
    "GateCall"
];

pub fn enum_name_directive_set(e: DirectiveSet) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_DIRECTIVE_SET[index as usize]
}

pub struct DirectiveSetUnionTableOffset {}
// struct Count, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Count {
  type_id_: u8,
  padding0__: u8,  padding1__: u16,  padding2__: u32,
  count_: u64,
} // pub struct Count
impl flatbuffers::SafeSliceAccess for Count {}
impl<'a> flatbuffers::Follow<'a> for Count {
  type Inner = &'a Count;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Count>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Count {
  type Inner = &'a Count;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Count>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Count {
    type Output = Count;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Count as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Count {
    type Output = Count;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Count as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Count {
  pub fn new<'a>(_type_id: u8, _count: u64) -> Self {
    Count {
      type_id_: _type_id.to_little_endian(),
      count_: _count.to_little_endian(),

      padding0__: 0,padding1__: 0,padding2__: 0,
    }
  }
  pub fn type_id<'a>(&'a self) -> u8 {
    self.type_id_.from_little_endian()
  }
  pub fn count<'a>(&'a self) -> u64 {
    self.count_.from_little_endian()
  }
}

// struct Conversion, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Conversion {
  output_count_: Count,
  input_count_: Count,
} // pub struct Conversion
impl flatbuffers::SafeSliceAccess for Conversion {}
impl<'a> flatbuffers::Follow<'a> for Conversion {
  type Inner = &'a Conversion;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Conversion>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Conversion {
  type Inner = &'a Conversion;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Conversion>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Conversion {
    type Output = Conversion;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Conversion as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Conversion {
    type Output = Conversion;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Conversion as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Conversion {
  pub fn new<'a>(_output_count: &'a Count, _input_count: &'a Count) -> Self {
    Conversion {
      output_count_: *_output_count,
      input_count_: *_input_count,

    }
  }
  pub fn output_count<'a>(&'a self) -> &'a Count {
    &self.output_count_
  }
  pub fn input_count<'a>(&'a self) -> &'a Count {
    &self.input_count_
  }
}

pub enum RelationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Relation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Relation<'a> {
    type Inner = Relation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Relation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Relation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RelationArgs<'args>) -> flatbuffers::WIPOffset<Relation<'bldr>> {
      let mut builder = RelationBuilder::new(_fbb);
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.functions { builder.add_functions(x); }
      if let Some(x) = args.conversions { builder.add_conversions(x); }
      if let Some(x) = args.types { builder.add_types(x); }
      if let Some(x) = args.plugins { builder.add_plugins(x); }
      if let Some(x) = args.version { builder.add_version(x); }
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_PLUGINS: flatbuffers::VOffsetT = 6;
    pub const VT_TYPES: flatbuffers::VOffsetT = 8;
    pub const VT_CONVERSIONS: flatbuffers::VOffsetT = 10;
    pub const VT_FUNCTIONS: flatbuffers::VOffsetT = 12;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Relation::VT_VERSION, None)
  }
  #[inline]
  pub fn plugins(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(Relation::VT_PLUGINS, None)
  }
  #[inline]
  pub fn types(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Value<'a>>>>>(Relation::VT_TYPES, None)
  }
  #[inline]
  pub fn conversions(&self) -> Option<&'a [Conversion]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Conversion>>>(Relation::VT_CONVERSIONS, None).map(|v| v.safe_slice() )
  }
  #[inline]
  pub fn functions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Function<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Function<'a>>>>>(Relation::VT_FUNCTIONS, None)
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Directive<'a>>>>>(Relation::VT_DIRECTIVES, None)
  }
}

pub struct RelationArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub plugins: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Value<'a >>>>>,
    pub conversions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Conversion>>>,
    pub functions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Function<'a >>>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Directive<'a >>>>>,
}
impl<'a> Default for RelationArgs<'a> {
    #[inline]
    fn default() -> Self {
        RelationArgs {
            version: None,
            plugins: None,
            types: None,
            conversions: None,
            functions: None,
            directives: None,
        }
    }
}
pub struct RelationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelationBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_VERSION, version);
  }
  #[inline]
  pub fn add_plugins(&mut self, plugins: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_PLUGINS, plugins);
  }
  #[inline]
  pub fn add_types(&mut self, types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_TYPES, types);
  }
  #[inline]
  pub fn add_conversions(&mut self, conversions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Conversion>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_CONVERSIONS, conversions);
  }
  #[inline]
  pub fn add_functions(&mut self, functions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Function<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_FUNCTIONS, functions);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directive<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Relation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PublicInputsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PublicInputs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PublicInputs<'a> {
    type Inner = PublicInputs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PublicInputs<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PublicInputs {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PublicInputsArgs<'args>) -> flatbuffers::WIPOffset<PublicInputs<'bldr>> {
      let mut builder = PublicInputsBuilder::new(_fbb);
      if let Some(x) = args.inputs { builder.add_inputs(x); }
      if let Some(x) = args.type_ { builder.add_type_(x); }
      if let Some(x) = args.version { builder.add_version(x); }
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PublicInputs::VT_VERSION, None)
  }
  #[inline]
  pub fn type_(&self) -> Option<Value<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Value<'a>>>(PublicInputs::VT_TYPE_, None)
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Value<'a>>>>>(PublicInputs::VT_INPUTS, None)
  }
}

pub struct PublicInputsArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub type_: Option<flatbuffers::WIPOffset<Value<'a >>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Value<'a >>>>>,
}
impl<'a> Default for PublicInputsArgs<'a> {
    #[inline]
    fn default() -> Self {
        PublicInputsArgs {
            version: None,
            type_: None,
            inputs: None,
        }
    }
}
pub struct PublicInputsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PublicInputsBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PublicInputs::VT_VERSION, version);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Value<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Value>>(PublicInputs::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PublicInputs::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PublicInputsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PublicInputsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PublicInputs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PrivateInputsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PrivateInputs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrivateInputs<'a> {
    type Inner = PrivateInputs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PrivateInputs<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrivateInputs {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrivateInputsArgs<'args>) -> flatbuffers::WIPOffset<PrivateInputs<'bldr>> {
      let mut builder = PrivateInputsBuilder::new(_fbb);
      if let Some(x) = args.inputs { builder.add_inputs(x); }
      if let Some(x) = args.type_ { builder.add_type_(x); }
      if let Some(x) = args.version { builder.add_version(x); }
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PrivateInputs::VT_VERSION, None)
  }
  #[inline]
  pub fn type_(&self) -> Option<Value<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Value<'a>>>(PrivateInputs::VT_TYPE_, None)
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Value<'a>>>>>(PrivateInputs::VT_INPUTS, None)
  }
}

pub struct PrivateInputsArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub type_: Option<flatbuffers::WIPOffset<Value<'a >>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Value<'a >>>>>,
}
impl<'a> Default for PrivateInputsArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrivateInputsArgs {
            version: None,
            type_: None,
            inputs: None,
        }
    }
}
pub struct PrivateInputsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrivateInputsBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrivateInputs::VT_VERSION, version);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Value<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Value>>(PrivateInputs::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrivateInputs::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrivateInputsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PrivateInputsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrivateInputs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Value<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Value<'a> {
    type Inner = Value<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Value<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Value {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ValueArgs<'args>) -> flatbuffers::WIPOffset<Value<'bldr>> {
      let mut builder = ValueBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      builder.finish()
    }

    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Value::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

pub struct ValueArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for ValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        ValueArgs {
            value: None,
        }
    }
}
pub struct ValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Value<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WireRangeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WireRange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WireRange<'a> {
    type Inner = WireRange<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> WireRange<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WireRange {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WireRangeArgs) -> flatbuffers::WIPOffset<WireRange<'bldr>> {
      let mut builder = WireRangeBuilder::new(_fbb);
      builder.add_last_id(args.last_id);
      builder.add_first_id(args.first_id);
      builder.finish()
    }

    pub const VT_FIRST_ID: flatbuffers::VOffsetT = 4;
    pub const VT_LAST_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn first_id(&self) -> u64 {
    self._tab.get::<u64>(WireRange::VT_FIRST_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn last_id(&self) -> u64 {
    self._tab.get::<u64>(WireRange::VT_LAST_ID, Some(0)).unwrap()
  }
}

pub struct WireRangeArgs {
    pub first_id: u64,
    pub last_id: u64,
}
impl<'a> Default for WireRangeArgs {
    #[inline]
    fn default() -> Self {
        WireRangeArgs {
            first_id: 0,
            last_id: 0,
        }
    }
}
pub struct WireRangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WireRangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_first_id(&mut self, first_id: u64) {
    self.fbb_.push_slot::<u64>(WireRange::VT_FIRST_ID, first_id, 0);
  }
  #[inline]
  pub fn add_last_id(&mut self, last_id: u64) {
    self.fbb_.push_slot::<u64>(WireRange::VT_LAST_ID, last_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WireRangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WireRangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WireRange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateConstantOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateConstant<'a> {
    type Inner = GateConstant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateConstant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateConstant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateConstantArgs<'args>) -> flatbuffers::WIPOffset<GateConstant<'bldr>> {
      let mut builder = GateConstantBuilder::new(_fbb);
      builder.add_out_id(args.out_id);
      if let Some(x) = args.constant { builder.add_constant(x); }
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GateConstant::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    self._tab.get::<u64>(GateConstant::VT_OUT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn constant(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateConstant::VT_CONSTANT, None).map(|v| v.safe_slice())
  }
}

pub struct GateConstantArgs<'a> {
    pub type_id: u8,
    pub out_id: u64,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GateConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateConstantArgs {
            type_id: 0,
            out_id: 0,
            constant: None,
        }
    }
}
pub struct GateConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateConstant::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateConstant::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAssertZeroOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAssertZero<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAssertZero<'a> {
    type Inner = GateAssertZero<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAssertZero<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAssertZero {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAssertZeroArgs) -> flatbuffers::WIPOffset<GateAssertZero<'bldr>> {
      let mut builder = GateAssertZeroBuilder::new(_fbb);
      builder.add_in_id(args.in_id);
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_IN_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GateAssertZero::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    self._tab.get::<u64>(GateAssertZero::VT_IN_ID, Some(0)).unwrap()
  }
}

pub struct GateAssertZeroArgs {
    pub type_id: u8,
    pub in_id: u64,
}
impl<'a> Default for GateAssertZeroArgs {
    #[inline]
    fn default() -> Self {
        GateAssertZeroArgs {
            type_id: 0,
            in_id: 0,
        }
    }
}
pub struct GateAssertZeroBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAssertZeroBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateAssertZero::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateAssertZero::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAssertZeroBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAssertZeroBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAssertZero<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateCopyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateCopy<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateCopy<'a> {
    type Inner = GateCopy<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateCopy<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateCopy {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateCopyArgs) -> flatbuffers::WIPOffset<GateCopy<'bldr>> {
      let mut builder = GateCopyBuilder::new(_fbb);
      builder.add_in_id(args.in_id);
      builder.add_out_id(args.out_id);
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_IN_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GateCopy::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    self._tab.get::<u64>(GateCopy::VT_OUT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    self._tab.get::<u64>(GateCopy::VT_IN_ID, Some(0)).unwrap()
  }
}

pub struct GateCopyArgs {
    pub type_id: u8,
    pub out_id: u64,
    pub in_id: u64,
}
impl<'a> Default for GateCopyArgs {
    #[inline]
    fn default() -> Self {
        GateCopyArgs {
            type_id: 0,
            out_id: 0,
            in_id: 0,
        }
    }
}
pub struct GateCopyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateCopyBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateCopy::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateCopy::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateCopy::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateCopyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateCopyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateCopy<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAddOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAdd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAdd<'a> {
    type Inner = GateAdd<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAdd<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAdd {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAddArgs) -> flatbuffers::WIPOffset<GateAdd<'bldr>> {
      let mut builder = GateAddBuilder::new(_fbb);
      builder.add_right_id(args.right_id);
      builder.add_left_id(args.left_id);
      builder.add_out_id(args.out_id);
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_LEFT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_RIGHT_ID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GateAdd::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    self._tab.get::<u64>(GateAdd::VT_OUT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn left_id(&self) -> u64 {
    self._tab.get::<u64>(GateAdd::VT_LEFT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn right_id(&self) -> u64 {
    self._tab.get::<u64>(GateAdd::VT_RIGHT_ID, Some(0)).unwrap()
  }
}

pub struct GateAddArgs {
    pub type_id: u8,
    pub out_id: u64,
    pub left_id: u64,
    pub right_id: u64,
}
impl<'a> Default for GateAddArgs {
    #[inline]
    fn default() -> Self {
        GateAddArgs {
            type_id: 0,
            out_id: 0,
            left_id: 0,
            right_id: 0,
        }
    }
}
pub struct GateAddBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateAdd::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateAdd::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_left_id(&mut self, left_id: u64) {
    self.fbb_.push_slot::<u64>(GateAdd::VT_LEFT_ID, left_id, 0);
  }
  #[inline]
  pub fn add_right_id(&mut self, right_id: u64) {
    self.fbb_.push_slot::<u64>(GateAdd::VT_RIGHT_ID, right_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAdd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateMulOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateMul<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMul<'a> {
    type Inner = GateMul<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateMul<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateMul {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateMulArgs) -> flatbuffers::WIPOffset<GateMul<'bldr>> {
      let mut builder = GateMulBuilder::new(_fbb);
      builder.add_right_id(args.right_id);
      builder.add_left_id(args.left_id);
      builder.add_out_id(args.out_id);
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_LEFT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_RIGHT_ID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GateMul::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    self._tab.get::<u64>(GateMul::VT_OUT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn left_id(&self) -> u64 {
    self._tab.get::<u64>(GateMul::VT_LEFT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn right_id(&self) -> u64 {
    self._tab.get::<u64>(GateMul::VT_RIGHT_ID, Some(0)).unwrap()
  }
}

pub struct GateMulArgs {
    pub type_id: u8,
    pub out_id: u64,
    pub left_id: u64,
    pub right_id: u64,
}
impl<'a> Default for GateMulArgs {
    #[inline]
    fn default() -> Self {
        GateMulArgs {
            type_id: 0,
            out_id: 0,
            left_id: 0,
            right_id: 0,
        }
    }
}
pub struct GateMulBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateMul::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateMul::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_left_id(&mut self, left_id: u64) {
    self.fbb_.push_slot::<u64>(GateMul::VT_LEFT_ID, left_id, 0);
  }
  #[inline]
  pub fn add_right_id(&mut self, right_id: u64) {
    self.fbb_.push_slot::<u64>(GateMul::VT_RIGHT_ID, right_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMul<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAddConstantOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAddConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAddConstant<'a> {
    type Inner = GateAddConstant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAddConstant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAddConstant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAddConstantArgs<'args>) -> flatbuffers::WIPOffset<GateAddConstant<'bldr>> {
      let mut builder = GateAddConstantBuilder::new(_fbb);
      builder.add_in_id(args.in_id);
      builder.add_out_id(args.out_id);
      if let Some(x) = args.constant { builder.add_constant(x); }
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_IN_ID: flatbuffers::VOffsetT = 8;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GateAddConstant::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    self._tab.get::<u64>(GateAddConstant::VT_OUT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    self._tab.get::<u64>(GateAddConstant::VT_IN_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn constant(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateAddConstant::VT_CONSTANT, None).map(|v| v.safe_slice())
  }
}

pub struct GateAddConstantArgs<'a> {
    pub type_id: u8,
    pub out_id: u64,
    pub in_id: u64,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GateAddConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAddConstantArgs {
            type_id: 0,
            out_id: 0,
            in_id: 0,
            constant: None,
        }
    }
}
pub struct GateAddConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateAddConstant::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateAddConstant::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateAddConstant::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateAddConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAddConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateMulConstantOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateMulConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMulConstant<'a> {
    type Inner = GateMulConstant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateMulConstant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateMulConstant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateMulConstantArgs<'args>) -> flatbuffers::WIPOffset<GateMulConstant<'bldr>> {
      let mut builder = GateMulConstantBuilder::new(_fbb);
      builder.add_in_id(args.in_id);
      builder.add_out_id(args.out_id);
      if let Some(x) = args.constant { builder.add_constant(x); }
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_IN_ID: flatbuffers::VOffsetT = 8;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GateMulConstant::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    self._tab.get::<u64>(GateMulConstant::VT_OUT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    self._tab.get::<u64>(GateMulConstant::VT_IN_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn constant(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateMulConstant::VT_CONSTANT, None).map(|v| v.safe_slice())
  }
}

pub struct GateMulConstantArgs<'a> {
    pub type_id: u8,
    pub out_id: u64,
    pub in_id: u64,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GateMulConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateMulConstantArgs {
            type_id: 0,
            out_id: 0,
            in_id: 0,
            constant: None,
        }
    }
}
pub struct GateMulConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateMulConstant::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateMulConstant::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateMulConstant::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateMulConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMulConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GatePublicInputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GatePublicInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatePublicInput<'a> {
    type Inner = GatePublicInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GatePublicInput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GatePublicInput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GatePublicInputArgs) -> flatbuffers::WIPOffset<GatePublicInput<'bldr>> {
      let mut builder = GatePublicInputBuilder::new(_fbb);
      builder.add_out_id(args.out_id);
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GatePublicInput::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    self._tab.get::<u64>(GatePublicInput::VT_OUT_ID, Some(0)).unwrap()
  }
}

pub struct GatePublicInputArgs {
    pub type_id: u8,
    pub out_id: u64,
}
impl<'a> Default for GatePublicInputArgs {
    #[inline]
    fn default() -> Self {
        GatePublicInputArgs {
            type_id: 0,
            out_id: 0,
        }
    }
}
pub struct GatePublicInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatePublicInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GatePublicInput::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GatePublicInput::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatePublicInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatePublicInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatePublicInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GatePrivateInputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GatePrivateInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatePrivateInput<'a> {
    type Inner = GatePrivateInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GatePrivateInput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GatePrivateInput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GatePrivateInputArgs) -> flatbuffers::WIPOffset<GatePrivateInput<'bldr>> {
      let mut builder = GatePrivateInputBuilder::new(_fbb);
      builder.add_out_id(args.out_id);
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GatePrivateInput::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    self._tab.get::<u64>(GatePrivateInput::VT_OUT_ID, Some(0)).unwrap()
  }
}

pub struct GatePrivateInputArgs {
    pub type_id: u8,
    pub out_id: u64,
}
impl<'a> Default for GatePrivateInputArgs {
    #[inline]
    fn default() -> Self {
        GatePrivateInputArgs {
            type_id: 0,
            out_id: 0,
        }
    }
}
pub struct GatePrivateInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatePrivateInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GatePrivateInput::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GatePrivateInput::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatePrivateInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatePrivateInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatePrivateInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateNewOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateNew<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateNew<'a> {
    type Inner = GateNew<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateNew<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateNew {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateNewArgs) -> flatbuffers::WIPOffset<GateNew<'bldr>> {
      let mut builder = GateNewBuilder::new(_fbb);
      builder.add_last_id(args.last_id);
      builder.add_first_id(args.first_id);
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_FIRST_ID: flatbuffers::VOffsetT = 6;
    pub const VT_LAST_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GateNew::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn first_id(&self) -> u64 {
    self._tab.get::<u64>(GateNew::VT_FIRST_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn last_id(&self) -> u64 {
    self._tab.get::<u64>(GateNew::VT_LAST_ID, Some(0)).unwrap()
  }
}

pub struct GateNewArgs {
    pub type_id: u8,
    pub first_id: u64,
    pub last_id: u64,
}
impl<'a> Default for GateNewArgs {
    #[inline]
    fn default() -> Self {
        GateNewArgs {
            type_id: 0,
            first_id: 0,
            last_id: 0,
        }
    }
}
pub struct GateNewBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateNewBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateNew::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_first_id(&mut self, first_id: u64) {
    self.fbb_.push_slot::<u64>(GateNew::VT_FIRST_ID, first_id, 0);
  }
  #[inline]
  pub fn add_last_id(&mut self, last_id: u64) {
    self.fbb_.push_slot::<u64>(GateNew::VT_LAST_ID, last_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateNewBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateNewBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateNew<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateDeleteOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateDelete<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateDelete<'a> {
    type Inner = GateDelete<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateDelete<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateDelete {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateDeleteArgs) -> flatbuffers::WIPOffset<GateDelete<'bldr>> {
      let mut builder = GateDeleteBuilder::new(_fbb);
      builder.add_last_id(args.last_id);
      builder.add_first_id(args.first_id);
      builder.add_type_id(args.type_id);
      builder.finish()
    }

    pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_FIRST_ID: flatbuffers::VOffsetT = 6;
    pub const VT_LAST_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn type_id(&self) -> u8 {
    self._tab.get::<u8>(GateDelete::VT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn first_id(&self) -> u64 {
    self._tab.get::<u64>(GateDelete::VT_FIRST_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn last_id(&self) -> u64 {
    self._tab.get::<u64>(GateDelete::VT_LAST_ID, Some(0)).unwrap()
  }
}

pub struct GateDeleteArgs {
    pub type_id: u8,
    pub first_id: u64,
    pub last_id: u64,
}
impl<'a> Default for GateDeleteArgs {
    #[inline]
    fn default() -> Self {
        GateDeleteArgs {
            type_id: 0,
            first_id: 0,
            last_id: 0,
        }
    }
}
pub struct GateDeleteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateDeleteBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateDelete::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_first_id(&mut self, first_id: u64) {
    self.fbb_.push_slot::<u64>(GateDelete::VT_FIRST_ID, first_id, 0);
  }
  #[inline]
  pub fn add_last_id(&mut self, last_id: u64) {
    self.fbb_.push_slot::<u64>(GateDelete::VT_LAST_ID, last_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateDeleteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateDeleteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateDelete<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateConvertOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateConvert<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateConvert<'a> {
    type Inner = GateConvert<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateConvert<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateConvert {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateConvertArgs) -> flatbuffers::WIPOffset<GateConvert<'bldr>> {
      let mut builder = GateConvertBuilder::new(_fbb);
      builder.add_in_last_id(args.in_last_id);
      builder.add_in_first_id(args.in_first_id);
      builder.add_out_last_id(args.out_last_id);
      builder.add_out_first_id(args.out_first_id);
      builder.add_in_type_id(args.in_type_id);
      builder.add_out_type_id(args.out_type_id);
      builder.finish()
    }

    pub const VT_OUT_TYPE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_FIRST_ID: flatbuffers::VOffsetT = 6;
    pub const VT_OUT_LAST_ID: flatbuffers::VOffsetT = 8;
    pub const VT_IN_TYPE_ID: flatbuffers::VOffsetT = 10;
    pub const VT_IN_FIRST_ID: flatbuffers::VOffsetT = 12;
    pub const VT_IN_LAST_ID: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn out_type_id(&self) -> u8 {
    self._tab.get::<u8>(GateConvert::VT_OUT_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_first_id(&self) -> u64 {
    self._tab.get::<u64>(GateConvert::VT_OUT_FIRST_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn out_last_id(&self) -> u64 {
    self._tab.get::<u64>(GateConvert::VT_OUT_LAST_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn in_type_id(&self) -> u8 {
    self._tab.get::<u8>(GateConvert::VT_IN_TYPE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn in_first_id(&self) -> u64 {
    self._tab.get::<u64>(GateConvert::VT_IN_FIRST_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn in_last_id(&self) -> u64 {
    self._tab.get::<u64>(GateConvert::VT_IN_LAST_ID, Some(0)).unwrap()
  }
}

pub struct GateConvertArgs {
    pub out_type_id: u8,
    pub out_first_id: u64,
    pub out_last_id: u64,
    pub in_type_id: u8,
    pub in_first_id: u64,
    pub in_last_id: u64,
}
impl<'a> Default for GateConvertArgs {
    #[inline]
    fn default() -> Self {
        GateConvertArgs {
            out_type_id: 0,
            out_first_id: 0,
            out_last_id: 0,
            in_type_id: 0,
            in_first_id: 0,
            in_last_id: 0,
        }
    }
}
pub struct GateConvertBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateConvertBuilder<'a, 'b> {
  #[inline]
  pub fn add_out_type_id(&mut self, out_type_id: u8) {
    self.fbb_.push_slot::<u8>(GateConvert::VT_OUT_TYPE_ID, out_type_id, 0);
  }
  #[inline]
  pub fn add_out_first_id(&mut self, out_first_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_OUT_FIRST_ID, out_first_id, 0);
  }
  #[inline]
  pub fn add_out_last_id(&mut self, out_last_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_OUT_LAST_ID, out_last_id, 0);
  }
  #[inline]
  pub fn add_in_type_id(&mut self, in_type_id: u8) {
    self.fbb_.push_slot::<u8>(GateConvert::VT_IN_TYPE_ID, in_type_id, 0);
  }
  #[inline]
  pub fn add_in_first_id(&mut self, in_first_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_IN_FIRST_ID, in_first_id, 0);
  }
  #[inline]
  pub fn add_in_last_id(&mut self, in_last_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_IN_LAST_ID, in_last_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateConvertBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateConvertBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateConvert<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GatesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Gates<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Gates<'a> {
    type Inner = Gates<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Gates<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Gates {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GatesArgs<'args>) -> flatbuffers::WIPOffset<Gates<'bldr>> {
      let mut builder = GatesBuilder::new(_fbb);
      if let Some(x) = args.gates { builder.add_gates(x); }
      builder.finish()
    }

    pub const VT_GATES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn gates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Directive<'a>>>>>(Gates::VT_GATES, None)
  }
}

pub struct GatesArgs<'a> {
    pub gates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Directive<'a >>>>>,
}
impl<'a> Default for GatesArgs<'a> {
    #[inline]
    fn default() -> Self {
        GatesArgs {
            gates: None,
        }
    }
}
pub struct GatesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatesBuilder<'a, 'b> {
  #[inline]
  pub fn add_gates(&mut self, gates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directive<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Gates::VT_GATES, gates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Gates<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PluginBodyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PluginBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginBody<'a> {
    type Inner = PluginBody<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PluginBody<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PluginBody {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PluginBodyArgs<'args>) -> flatbuffers::WIPOffset<PluginBody<'bldr>> {
      let mut builder = PluginBodyBuilder::new(_fbb);
      if let Some(x) = args.private_count { builder.add_private_count(x); }
      if let Some(x) = args.public_count { builder.add_public_count(x); }
      if let Some(x) = args.params { builder.add_params(x); }
      if let Some(x) = args.operation { builder.add_operation(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATION: flatbuffers::VOffsetT = 6;
    pub const VT_PARAMS: flatbuffers::VOffsetT = 8;
    pub const VT_PUBLIC_COUNT: flatbuffers::VOffsetT = 10;
    pub const VT_PRIVATE_COUNT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginBody::VT_NAME, None)
  }
  #[inline]
  pub fn operation(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginBody::VT_OPERATION, None)
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(PluginBody::VT_PARAMS, None)
  }
  #[inline]
  pub fn public_count(&self) -> Option<&'a [Count]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Count>>>(PluginBody::VT_PUBLIC_COUNT, None).map(|v| v.safe_slice() )
  }
  #[inline]
  pub fn private_count(&self) -> Option<&'a [Count]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Count>>>(PluginBody::VT_PRIVATE_COUNT, None).map(|v| v.safe_slice() )
  }
}

pub struct PluginBodyArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub operation: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub public_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Count>>>,
    pub private_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Count>>>,
}
impl<'a> Default for PluginBodyArgs<'a> {
    #[inline]
    fn default() -> Self {
        PluginBodyArgs {
            name: None,
            operation: None,
            params: None,
            public_count: None,
            private_count: None,
        }
    }
}
pub struct PluginBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PluginBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_NAME, name);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_OPERATION, operation);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_PARAMS, params);
  }
  #[inline]
  pub fn add_public_count(&mut self, public_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_PUBLIC_COUNT, public_count);
  }
  #[inline]
  pub fn add_private_count(&mut self, private_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_PRIVATE_COUNT, private_count);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PluginBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PluginBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FunctionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Function<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Function<'a> {
    type Inner = Function<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Function<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Function {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FunctionArgs<'args>) -> flatbuffers::WIPOffset<Function<'bldr>> {
      let mut builder = FunctionBuilder::new(_fbb);
      if let Some(x) = args.body { builder.add_body(x); }
      if let Some(x) = args.input_count { builder.add_input_count(x); }
      if let Some(x) = args.output_count { builder.add_output_count(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_body_type(args.body_type);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_INPUT_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_BODY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Function::VT_NAME, None)
  }
  #[inline]
  pub fn output_count(&self) -> Option<&'a [Count]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Count>>>(Function::VT_OUTPUT_COUNT, None).map(|v| v.safe_slice() )
  }
  #[inline]
  pub fn input_count(&self) -> Option<&'a [Count]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Count>>>(Function::VT_INPUT_COUNT, None).map(|v| v.safe_slice() )
  }
  #[inline]
  pub fn body_type(&self) -> FunctionBody {
    self._tab.get::<FunctionBody>(Function::VT_BODY_TYPE, Some(FunctionBody::NONE)).unwrap()
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Function::VT_BODY, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_gates(&self) -> Option<Gates<'a>> {
    if self.body_type() == FunctionBody::Gates {
      self.body().map(|u| Gates::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_plugin_body(&self) -> Option<PluginBody<'a>> {
    if self.body_type() == FunctionBody::PluginBody {
      self.body().map(|u| PluginBody::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct FunctionArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub output_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Count>>>,
    pub input_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Count>>>,
    pub body_type: FunctionBody,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FunctionArgs<'a> {
    #[inline]
    fn default() -> Self {
        FunctionArgs {
            name: None,
            output_count: None,
            input_count: None,
            body_type: FunctionBody::NONE,
            body: None,
        }
    }
}
pub struct FunctionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FunctionBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_NAME, name);
  }
  #[inline]
  pub fn add_output_count(&mut self, output_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_OUTPUT_COUNT, output_count);
  }
  #[inline]
  pub fn add_input_count(&mut self, input_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_INPUT_COUNT, input_count);
  }
  #[inline]
  pub fn add_body_type(&mut self, body_type: FunctionBody) {
    self.fbb_.push_slot::<FunctionBody>(Function::VT_BODY_TYPE, body_type, FunctionBody::NONE);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunctionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FunctionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Function<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateCallOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateCall<'a> {
    type Inner = GateCall<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateCall<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateCall {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateCallArgs<'args>) -> flatbuffers::WIPOffset<GateCall<'bldr>> {
      let mut builder = GateCallBuilder::new(_fbb);
      if let Some(x) = args.in_ids { builder.add_in_ids(x); }
      if let Some(x) = args.out_ids { builder.add_out_ids(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_OUT_IDS: flatbuffers::VOffsetT = 6;
    pub const VT_IN_IDS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GateCall::VT_NAME, None)
  }
  #[inline]
  pub fn out_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WireRange<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<WireRange<'a>>>>>(GateCall::VT_OUT_IDS, None)
  }
  #[inline]
  pub fn in_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WireRange<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<WireRange<'a>>>>>(GateCall::VT_IN_IDS, None)
  }
}

pub struct GateCallArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub out_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<WireRange<'a >>>>>,
    pub in_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<WireRange<'a >>>>>,
}
impl<'a> Default for GateCallArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateCallArgs {
            name: None,
            out_ids: None,
            in_ids: None,
        }
    }
}
pub struct GateCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_NAME, name);
  }
  #[inline]
  pub fn add_out_ids(&mut self, out_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WireRange<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_OUT_IDS, out_ids);
  }
  #[inline]
  pub fn add_in_ids(&mut self, in_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WireRange<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_IN_IDS, in_ids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DirectiveOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Directive<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Directive<'a> {
    type Inner = Directive<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Directive<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Directive {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DirectiveArgs) -> flatbuffers::WIPOffset<Directive<'bldr>> {
      let mut builder = DirectiveBuilder::new(_fbb);
      if let Some(x) = args.directive { builder.add_directive(x); }
      builder.add_directive_type(args.directive_type);
      builder.finish()
    }

    pub const VT_DIRECTIVE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_DIRECTIVE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn directive_type(&self) -> DirectiveSet {
    self._tab.get::<DirectiveSet>(Directive::VT_DIRECTIVE_TYPE, Some(DirectiveSet::NONE)).unwrap()
  }
  #[inline]
  pub fn directive(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Directive::VT_DIRECTIVE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_constant(&self) -> Option<GateConstant<'a>> {
    if self.directive_type() == DirectiveSet::GateConstant {
      self.directive().map(|u| GateConstant::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_assert_zero(&self) -> Option<GateAssertZero<'a>> {
    if self.directive_type() == DirectiveSet::GateAssertZero {
      self.directive().map(|u| GateAssertZero::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_copy(&self) -> Option<GateCopy<'a>> {
    if self.directive_type() == DirectiveSet::GateCopy {
      self.directive().map(|u| GateCopy::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_add(&self) -> Option<GateAdd<'a>> {
    if self.directive_type() == DirectiveSet::GateAdd {
      self.directive().map(|u| GateAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_mul(&self) -> Option<GateMul<'a>> {
    if self.directive_type() == DirectiveSet::GateMul {
      self.directive().map(|u| GateMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_add_constant(&self) -> Option<GateAddConstant<'a>> {
    if self.directive_type() == DirectiveSet::GateAddConstant {
      self.directive().map(|u| GateAddConstant::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_mul_constant(&self) -> Option<GateMulConstant<'a>> {
    if self.directive_type() == DirectiveSet::GateMulConstant {
      self.directive().map(|u| GateMulConstant::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_public_input(&self) -> Option<GatePublicInput<'a>> {
    if self.directive_type() == DirectiveSet::GatePublicInput {
      self.directive().map(|u| GatePublicInput::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_private_input(&self) -> Option<GatePrivateInput<'a>> {
    if self.directive_type() == DirectiveSet::GatePrivateInput {
      self.directive().map(|u| GatePrivateInput::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_new(&self) -> Option<GateNew<'a>> {
    if self.directive_type() == DirectiveSet::GateNew {
      self.directive().map(|u| GateNew::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_delete(&self) -> Option<GateDelete<'a>> {
    if self.directive_type() == DirectiveSet::GateDelete {
      self.directive().map(|u| GateDelete::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_convert(&self) -> Option<GateConvert<'a>> {
    if self.directive_type() == DirectiveSet::GateConvert {
      self.directive().map(|u| GateConvert::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_call(&self) -> Option<GateCall<'a>> {
    if self.directive_type() == DirectiveSet::GateCall {
      self.directive().map(|u| GateCall::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct DirectiveArgs {
    pub directive_type: DirectiveSet,
    pub directive: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DirectiveArgs {
    #[inline]
    fn default() -> Self {
        DirectiveArgs {
            directive_type: DirectiveSet::NONE,
            directive: None,
        }
    }
}
pub struct DirectiveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DirectiveBuilder<'a, 'b> {
  #[inline]
  pub fn add_directive_type(&mut self, directive_type: DirectiveSet) {
    self.fbb_.push_slot::<DirectiveSet>(Directive::VT_DIRECTIVE_TYPE, directive_type, DirectiveSet::NONE);
  }
  #[inline]
  pub fn add_directive(&mut self, directive: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Directive::VT_DIRECTIVE, directive);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirectiveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DirectiveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Directive<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RootOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Root<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Root<'a> {
    type Inner = Root<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Root<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Root {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RootArgs) -> flatbuffers::WIPOffset<Root<'bldr>> {
      let mut builder = RootBuilder::new(_fbb);
      if let Some(x) = args.message { builder.add_message(x); }
      builder.add_message_type(args.message_type);
      builder.finish()
    }

    pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn message_type(&self) -> Message {
    self._tab.get::<Message>(Root::VT_MESSAGE_TYPE, Some(Message::NONE)).unwrap()
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Root::VT_MESSAGE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_relation(&self) -> Option<Relation<'a>> {
    if self.message_type() == Message::Relation {
      self.message().map(|u| Relation::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_public_inputs(&self) -> Option<PublicInputs<'a>> {
    if self.message_type() == Message::PublicInputs {
      self.message().map(|u| PublicInputs::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_private_inputs(&self) -> Option<PrivateInputs<'a>> {
    if self.message_type() == Message::PrivateInputs {
      self.message().map(|u| PrivateInputs::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct RootArgs {
    pub message_type: Message,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RootArgs {
    #[inline]
    fn default() -> Self {
        RootArgs {
            message_type: Message::NONE,
            message: None,
        }
    }
}
pub struct RootBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RootBuilder<'a, 'b> {
  #[inline]
  pub fn add_message_type(&mut self, message_type: Message) {
    self.fbb_.push_slot::<Message>(Root::VT_MESSAGE_TYPE, message_type, Message::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Root::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RootBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RootBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Root<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_root::<Root<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_size_prefixed_root::<Root<'a>>(buf)
}

pub const ROOT_IDENTIFIER: &'static str = "siev";

#[inline]
pub fn root_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, false);
}

#[inline]
pub fn root_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, true);
}

pub const ROOT_EXTENSION: &'static str = "sieve";

#[inline]
pub fn finish_root_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish(root, Some(ROOT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_root_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish_size_prefixed(root, Some(ROOT_IDENTIFIER));
}
}  // pub mod sieve_ir

