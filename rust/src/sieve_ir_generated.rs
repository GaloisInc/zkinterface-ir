// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod sieve_ir {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Message {
  NONE = 0,
  Relation = 1,
  Instance = 2,
  Witness = 3,

}

pub const ENUM_MIN_MESSAGE: u8 = 0;
pub const ENUM_MAX_MESSAGE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Message {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Message>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE:[Message; 4] = [
  Message::NONE,
  Message::Relation,
  Message::Instance,
  Message::Witness
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_MESSAGE:[&'static str; 4] = [
    "NONE",
    "Relation",
    "Instance",
    "Witness"
];

pub fn enum_name_message(e: Message) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_MESSAGE[index as usize]
}

pub struct MessageUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum WireListElementU {
  NONE = 0,
  Wire = 1,
  WireRange = 2,

}

pub const ENUM_MIN_WIRE_LIST_ELEMENT_U: u8 = 0;
pub const ENUM_MAX_WIRE_LIST_ELEMENT_U: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for WireListElementU {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for WireListElementU {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const WireListElementU;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const WireListElementU;
    unsafe { *p }
  }
}

impl flatbuffers::Push for WireListElementU {
    type Output = WireListElementU;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<WireListElementU>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WIRE_LIST_ELEMENT_U:[WireListElementU; 3] = [
  WireListElementU::NONE,
  WireListElementU::Wire,
  WireListElementU::WireRange
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_WIRE_LIST_ELEMENT_U:[&'static str; 3] = [
    "NONE",
    "Wire",
    "WireRange"
];

pub fn enum_name_wire_list_element_u(e: WireListElementU) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_WIRE_LIST_ELEMENT_U[index as usize]
}

pub struct WireListElementUUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum CaseInvokeU {
  NONE = 0,
  AbstractGateCall = 1,
  AbstractAnonCall = 2,

}

pub const ENUM_MIN_CASE_INVOKE_U: u8 = 0;
pub const ENUM_MAX_CASE_INVOKE_U: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for CaseInvokeU {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for CaseInvokeU {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const CaseInvokeU;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const CaseInvokeU;
    unsafe { *p }
  }
}

impl flatbuffers::Push for CaseInvokeU {
    type Output = CaseInvokeU;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<CaseInvokeU>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CASE_INVOKE_U:[CaseInvokeU; 3] = [
  CaseInvokeU::NONE,
  CaseInvokeU::AbstractGateCall,
  CaseInvokeU::AbstractAnonCall
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_CASE_INVOKE_U:[&'static str; 3] = [
    "NONE",
    "AbstractGateCall",
    "AbstractAnonCall"
];

pub fn enum_name_case_invoke_u(e: CaseInvokeU) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_CASE_INVOKE_U[index as usize]
}

pub struct CaseInvokeUUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum IterExpr {
  NONE = 0,
  IterExprConst = 1,
  IterExprName = 2,
  IterExprAdd = 3,
  IterExprSub = 4,
  IterExprMul = 5,
  IterExprDivConst = 6,

}

pub const ENUM_MIN_ITER_EXPR: u8 = 0;
pub const ENUM_MAX_ITER_EXPR: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for IterExpr {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for IterExpr {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const IterExpr;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const IterExpr;
    unsafe { *p }
  }
}

impl flatbuffers::Push for IterExpr {
    type Output = IterExpr;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<IterExpr>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ITER_EXPR:[IterExpr; 7] = [
  IterExpr::NONE,
  IterExpr::IterExprConst,
  IterExpr::IterExprName,
  IterExpr::IterExprAdd,
  IterExpr::IterExprSub,
  IterExpr::IterExprMul,
  IterExpr::IterExprDivConst
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_ITER_EXPR:[&'static str; 7] = [
    "NONE",
    "IterExprConst",
    "IterExprName",
    "IterExprAdd",
    "IterExprSub",
    "IterExprMul",
    "IterExprDivConst"
];

pub fn enum_name_iter_expr(e: IterExpr) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_ITER_EXPR[index as usize]
}

pub struct IterExprUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum IterExprWireListElementU {
  NONE = 0,
  IterExprWireNumber = 1,
  IterExprWireRange = 2,

}

pub const ENUM_MIN_ITER_EXPR_WIRE_LIST_ELEMENT_U: u8 = 0;
pub const ENUM_MAX_ITER_EXPR_WIRE_LIST_ELEMENT_U: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for IterExprWireListElementU {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for IterExprWireListElementU {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const IterExprWireListElementU;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const IterExprWireListElementU;
    unsafe { *p }
  }
}

impl flatbuffers::Push for IterExprWireListElementU {
    type Output = IterExprWireListElementU;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<IterExprWireListElementU>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ITER_EXPR_WIRE_LIST_ELEMENT_U:[IterExprWireListElementU; 3] = [
  IterExprWireListElementU::NONE,
  IterExprWireListElementU::IterExprWireNumber,
  IterExprWireListElementU::IterExprWireRange
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_ITER_EXPR_WIRE_LIST_ELEMENT_U:[&'static str; 3] = [
    "NONE",
    "IterExprWireNumber",
    "IterExprWireRange"
];

pub fn enum_name_iter_expr_wire_list_element_u(e: IterExprWireListElementU) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_ITER_EXPR_WIRE_LIST_ELEMENT_U[index as usize]
}

pub struct IterExprWireListElementUUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum ForLoopBody {
  NONE = 0,
  IterExprFunctionInvoke = 1,
  IterExprAnonFunction = 2,

}

pub const ENUM_MIN_FOR_LOOP_BODY: u8 = 0;
pub const ENUM_MAX_FOR_LOOP_BODY: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for ForLoopBody {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ForLoopBody {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const ForLoopBody;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const ForLoopBody;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ForLoopBody {
    type Output = ForLoopBody;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<ForLoopBody>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FOR_LOOP_BODY:[ForLoopBody; 3] = [
  ForLoopBody::NONE,
  ForLoopBody::IterExprFunctionInvoke,
  ForLoopBody::IterExprAnonFunction
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FOR_LOOP_BODY:[&'static str; 3] = [
    "NONE",
    "IterExprFunctionInvoke",
    "IterExprAnonFunction"
];

pub fn enum_name_for_loop_body(e: ForLoopBody) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FOR_LOOP_BODY[index as usize]
}

pub struct ForLoopBodyUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum DirectiveSet {
  NONE = 0,
  GateConstant = 1,
  GateAssertZero = 2,
  GateCopy = 3,
  GateAdd = 4,
  GateMul = 5,
  GateAddConstant = 6,
  GateMulConstant = 7,
  GateAnd = 8,
  GateXor = 9,
  GateNot = 10,
  GateInstance = 11,
  GateWitness = 12,
  GateFree = 13,
  GateCall = 14,
  GateAnonCall = 15,
  GateSwitch = 16,
  GateFor = 17,

}

pub const ENUM_MIN_DIRECTIVE_SET: u8 = 0;
pub const ENUM_MAX_DIRECTIVE_SET: u8 = 17;

impl<'a> flatbuffers::Follow<'a> for DirectiveSet {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for DirectiveSet {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const DirectiveSet;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const DirectiveSet;
    unsafe { *p }
  }
}

impl flatbuffers::Push for DirectiveSet {
    type Output = DirectiveSet;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<DirectiveSet>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIRECTIVE_SET:[DirectiveSet; 18] = [
  DirectiveSet::NONE,
  DirectiveSet::GateConstant,
  DirectiveSet::GateAssertZero,
  DirectiveSet::GateCopy,
  DirectiveSet::GateAdd,
  DirectiveSet::GateMul,
  DirectiveSet::GateAddConstant,
  DirectiveSet::GateMulConstant,
  DirectiveSet::GateAnd,
  DirectiveSet::GateXor,
  DirectiveSet::GateNot,
  DirectiveSet::GateInstance,
  DirectiveSet::GateWitness,
  DirectiveSet::GateFree,
  DirectiveSet::GateCall,
  DirectiveSet::GateAnonCall,
  DirectiveSet::GateSwitch,
  DirectiveSet::GateFor
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_DIRECTIVE_SET:[&'static str; 18] = [
    "NONE",
    "GateConstant",
    "GateAssertZero",
    "GateCopy",
    "GateAdd",
    "GateMul",
    "GateAddConstant",
    "GateMulConstant",
    "GateAnd",
    "GateXor",
    "GateNot",
    "GateInstance",
    "GateWitness",
    "GateFree",
    "GateCall",
    "GateAnonCall",
    "GateSwitch",
    "GateFor"
];

pub fn enum_name_directive_set(e: DirectiveSet) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_DIRECTIVE_SET[index as usize]
}

pub struct DirectiveSetUnionTableOffset {}
pub enum HeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
    type Inner = Header<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Header<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Header {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeaderArgs<'args>) -> flatbuffers::WIPOffset<Header<'bldr>> {
      let mut builder = HeaderBuilder::new(_fbb);
      builder.add_field_degree(args.field_degree);
      if let Some(x) = args.field_characteristic { builder.add_field_characteristic(x); }
      if let Some(x) = args.version { builder.add_version(x); }
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_FIELD_CHARACTERISTIC: flatbuffers::VOffsetT = 6;
    pub const VT_FIELD_DEGREE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_VERSION, None)
  }
  #[inline]
  pub fn field_characteristic(&self) -> Option<Value<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Value<'a>>>(Header::VT_FIELD_CHARACTERISTIC, None)
  }
  #[inline]
  pub fn field_degree(&self) -> u32 {
    self._tab.get::<u32>(Header::VT_FIELD_DEGREE, Some(0)).unwrap()
  }
}

pub struct HeaderArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub field_characteristic: Option<flatbuffers::WIPOffset<Value<'a >>>,
    pub field_degree: u32,
}
impl<'a> Default for HeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeaderArgs {
            version: None,
            field_characteristic: None,
            field_degree: 0,
        }
    }
}
pub struct HeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_VERSION, version);
  }
  #[inline]
  pub fn add_field_characteristic(&mut self, field_characteristic: flatbuffers::WIPOffset<Value<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Value>>(Header::VT_FIELD_CHARACTERISTIC, field_characteristic);
  }
  #[inline]
  pub fn add_field_degree(&mut self, field_degree: u32) {
    self.fbb_.push_slot::<u32>(Header::VT_FIELD_DEGREE, field_degree, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RelationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Relation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Relation<'a> {
    type Inner = Relation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Relation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Relation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RelationArgs<'args>) -> flatbuffers::WIPOffset<Relation<'bldr>> {
      let mut builder = RelationBuilder::new(_fbb);
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.functions { builder.add_functions(x); }
      if let Some(x) = args.features { builder.add_features(x); }
      if let Some(x) = args.gateset { builder.add_gateset(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_GATESET: flatbuffers::VOffsetT = 6;
    pub const VT_FEATURES: flatbuffers::VOffsetT = 8;
    pub const VT_FUNCTIONS: flatbuffers::VOffsetT = 10;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Relation::VT_HEADER, None)
  }
  #[inline]
  pub fn gateset(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Relation::VT_GATESET, None)
  }
  #[inline]
  pub fn features(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Relation::VT_FEATURES, None)
  }
  #[inline]
  pub fn functions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Function<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Function<'a>>>>>(Relation::VT_FUNCTIONS, None)
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Directive<'a>>>>>(Relation::VT_DIRECTIVES, None)
  }
}

pub struct RelationArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub gateset: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub features: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub functions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Function<'a >>>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Directive<'a >>>>>,
}
impl<'a> Default for RelationArgs<'a> {
    #[inline]
    fn default() -> Self {
        RelationArgs {
            header: None,
            gateset: None,
            features: None,
            functions: None,
            directives: None,
        }
    }
}
pub struct RelationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelationBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(Relation::VT_HEADER, header);
  }
  #[inline]
  pub fn add_gateset(&mut self, gateset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_GATESET, gateset);
  }
  #[inline]
  pub fn add_features(&mut self, features: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_FEATURES, features);
  }
  #[inline]
  pub fn add_functions(&mut self, functions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Function<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_FUNCTIONS, functions);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directive<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Relation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InstanceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Instance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Instance<'a> {
    type Inner = Instance<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Instance<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Instance {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InstanceArgs<'args>) -> flatbuffers::WIPOffset<Instance<'bldr>> {
      let mut builder = InstanceBuilder::new(_fbb);
      if let Some(x) = args.common_inputs { builder.add_common_inputs(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_COMMON_INPUTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Instance::VT_HEADER, None)
  }
  #[inline]
  pub fn common_inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Value<'a>>>>>(Instance::VT_COMMON_INPUTS, None)
  }
}

pub struct InstanceArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub common_inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Value<'a >>>>>,
}
impl<'a> Default for InstanceArgs<'a> {
    #[inline]
    fn default() -> Self {
        InstanceArgs {
            header: None,
            common_inputs: None,
        }
    }
}
pub struct InstanceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InstanceBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(Instance::VT_HEADER, header);
  }
  #[inline]
  pub fn add_common_inputs(&mut self, common_inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Instance::VT_COMMON_INPUTS, common_inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InstanceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InstanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Instance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WitnessOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Witness<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Witness<'a> {
    type Inner = Witness<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Witness<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Witness {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WitnessArgs<'args>) -> flatbuffers::WIPOffset<Witness<'bldr>> {
      let mut builder = WitnessBuilder::new(_fbb);
      if let Some(x) = args.short_witness { builder.add_short_witness(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_SHORT_WITNESS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Witness::VT_HEADER, None)
  }
  #[inline]
  pub fn short_witness(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Value<'a>>>>>(Witness::VT_SHORT_WITNESS, None)
  }
}

pub struct WitnessArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub short_witness: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Value<'a >>>>>,
}
impl<'a> Default for WitnessArgs<'a> {
    #[inline]
    fn default() -> Self {
        WitnessArgs {
            header: None,
            short_witness: None,
        }
    }
}
pub struct WitnessBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WitnessBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(Witness::VT_HEADER, header);
  }
  #[inline]
  pub fn add_short_witness(&mut self, short_witness: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Witness::VT_SHORT_WITNESS, short_witness);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WitnessBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WitnessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Witness<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WireOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Wire<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Wire<'a> {
    type Inner = Wire<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Wire<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Wire {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WireArgs) -> flatbuffers::WIPOffset<Wire<'bldr>> {
      let mut builder = WireBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(Wire::VT_ID, Some(0)).unwrap()
  }
}

pub struct WireArgs {
    pub id: u64,
}
impl<'a> Default for WireArgs {
    #[inline]
    fn default() -> Self {
        WireArgs {
            id: 0,
        }
    }
}
pub struct WireBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WireBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Wire::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WireBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WireBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Wire<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Value<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Value<'a> {
    type Inner = Value<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Value<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Value {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ValueArgs<'args>) -> flatbuffers::WIPOffset<Value<'bldr>> {
      let mut builder = ValueBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      builder.finish()
    }

    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Value::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

pub struct ValueArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for ValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        ValueArgs {
            value: None,
        }
    }
}
pub struct ValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Value<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WireRangeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WireRange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WireRange<'a> {
    type Inner = WireRange<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> WireRange<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WireRange {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WireRangeArgs<'args>) -> flatbuffers::WIPOffset<WireRange<'bldr>> {
      let mut builder = WireRangeBuilder::new(_fbb);
      if let Some(x) = args.last { builder.add_last(x); }
      if let Some(x) = args.first { builder.add_first(x); }
      builder.finish()
    }

    pub const VT_FIRST: flatbuffers::VOffsetT = 4;
    pub const VT_LAST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn first(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(WireRange::VT_FIRST, None)
  }
  #[inline]
  pub fn last(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(WireRange::VT_LAST, None)
  }
}

pub struct WireRangeArgs<'a> {
    pub first: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub last: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for WireRangeArgs<'a> {
    #[inline]
    fn default() -> Self {
        WireRangeArgs {
            first: None,
            last: None,
        }
    }
}
pub struct WireRangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WireRangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_first(&mut self, first: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(WireRange::VT_FIRST, first);
  }
  #[inline]
  pub fn add_last(&mut self, last: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(WireRange::VT_LAST, last);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WireRangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WireRangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WireRange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WireListElementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WireListElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WireListElement<'a> {
    type Inner = WireListElement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> WireListElement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WireListElement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WireListElementArgs) -> flatbuffers::WIPOffset<WireListElement<'bldr>> {
      let mut builder = WireListElementBuilder::new(_fbb);
      if let Some(x) = args.element { builder.add_element(x); }
      builder.add_element_type(args.element_type);
      builder.finish()
    }

    pub const VT_ELEMENT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ELEMENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn element_type(&self) -> WireListElementU {
    self._tab.get::<WireListElementU>(WireListElement::VT_ELEMENT_TYPE, Some(WireListElementU::NONE)).unwrap()
  }
  #[inline]
  pub fn element(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(WireListElement::VT_ELEMENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_wire(&self) -> Option<Wire<'a>> {
    if self.element_type() == WireListElementU::Wire {
      self.element().map(|u| Wire::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_wire_range(&self) -> Option<WireRange<'a>> {
    if self.element_type() == WireListElementU::WireRange {
      self.element().map(|u| WireRange::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct WireListElementArgs {
    pub element_type: WireListElementU,
    pub element: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for WireListElementArgs {
    #[inline]
    fn default() -> Self {
        WireListElementArgs {
            element_type: WireListElementU::NONE,
            element: None,
        }
    }
}
pub struct WireListElementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WireListElementBuilder<'a, 'b> {
  #[inline]
  pub fn add_element_type(&mut self, element_type: WireListElementU) {
    self.fbb_.push_slot::<WireListElementU>(WireListElement::VT_ELEMENT_TYPE, element_type, WireListElementU::NONE);
  }
  #[inline]
  pub fn add_element(&mut self, element: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WireListElement::VT_ELEMENT, element);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WireListElementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WireListElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WireListElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WireListOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WireList<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WireList<'a> {
    type Inner = WireList<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> WireList<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WireList {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WireListArgs<'args>) -> flatbuffers::WIPOffset<WireList<'bldr>> {
      let mut builder = WireListBuilder::new(_fbb);
      if let Some(x) = args.elements { builder.add_elements(x); }
      builder.finish()
    }

    pub const VT_ELEMENTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WireListElement<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<WireListElement<'a>>>>>(WireList::VT_ELEMENTS, None)
  }
}

pub struct WireListArgs<'a> {
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<WireListElement<'a >>>>>,
}
impl<'a> Default for WireListArgs<'a> {
    #[inline]
    fn default() -> Self {
        WireListArgs {
            elements: None,
        }
    }
}
pub struct WireListBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WireListBuilder<'a, 'b> {
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WireListElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WireList::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WireListBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WireListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WireList<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateConstantOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateConstant<'a> {
    type Inner = GateConstant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateConstant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateConstant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateConstantArgs<'args>) -> flatbuffers::WIPOffset<GateConstant<'bldr>> {
      let mut builder = GateConstantBuilder::new(_fbb);
      if let Some(x) = args.constant { builder.add_constant(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateConstant::VT_OUTPUT, None)
  }
  #[inline]
  pub fn constant(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateConstant::VT_CONSTANT, None).map(|v| v.safe_slice())
  }
}

pub struct GateConstantArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GateConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateConstantArgs {
            output: None,
            constant: None,
        }
    }
}
pub struct GateConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateConstant::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAssertZeroOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAssertZero<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAssertZero<'a> {
    type Inner = GateAssertZero<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAssertZero<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAssertZero {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAssertZeroArgs<'args>) -> flatbuffers::WIPOffset<GateAssertZero<'bldr>> {
      let mut builder = GateAssertZeroBuilder::new(_fbb);
      if let Some(x) = args.input { builder.add_input(x); }
      builder.finish()
    }

    pub const VT_INPUT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn input(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateAssertZero::VT_INPUT, None)
  }
}

pub struct GateAssertZeroArgs<'a> {
    pub input: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateAssertZeroArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAssertZeroArgs {
            input: None,
        }
    }
}
pub struct GateAssertZeroBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAssertZeroBuilder<'a, 'b> {
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateAssertZero::VT_INPUT, input);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAssertZeroBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAssertZeroBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAssertZero<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateCopyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateCopy<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateCopy<'a> {
    type Inner = GateCopy<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateCopy<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateCopy {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateCopyArgs<'args>) -> flatbuffers::WIPOffset<GateCopy<'bldr>> {
      let mut builder = GateCopyBuilder::new(_fbb);
      if let Some(x) = args.input { builder.add_input(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateCopy::VT_OUTPUT, None)
  }
  #[inline]
  pub fn input(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateCopy::VT_INPUT, None)
  }
}

pub struct GateCopyArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub input: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateCopyArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateCopyArgs {
            output: None,
            input: None,
        }
    }
}
pub struct GateCopyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateCopyBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateCopy::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateCopy::VT_INPUT, input);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateCopyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateCopyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateCopy<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAddOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAdd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAdd<'a> {
    type Inner = GateAdd<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAdd<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAdd {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAddArgs<'args>) -> flatbuffers::WIPOffset<GateAdd<'bldr>> {
      let mut builder = GateAddBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateAdd::VT_OUTPUT, None)
  }
  #[inline]
  pub fn left(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateAdd::VT_LEFT, None)
  }
  #[inline]
  pub fn right(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateAdd::VT_RIGHT, None)
  }
}

pub struct GateAddArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub left: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub right: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateAddArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAddArgs {
            output: None,
            left: None,
            right: None,
        }
    }
}
pub struct GateAddBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateAdd::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_left(&mut self, left: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateAdd::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right(&mut self, right: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateAdd::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAdd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateMulOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateMul<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMul<'a> {
    type Inner = GateMul<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateMul<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateMul {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateMulArgs<'args>) -> flatbuffers::WIPOffset<GateMul<'bldr>> {
      let mut builder = GateMulBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateMul::VT_OUTPUT, None)
  }
  #[inline]
  pub fn left(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateMul::VT_LEFT, None)
  }
  #[inline]
  pub fn right(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateMul::VT_RIGHT, None)
  }
}

pub struct GateMulArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub left: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub right: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateMulArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateMulArgs {
            output: None,
            left: None,
            right: None,
        }
    }
}
pub struct GateMulBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateMul::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_left(&mut self, left: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateMul::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right(&mut self, right: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateMul::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMul<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAddConstantOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAddConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAddConstant<'a> {
    type Inner = GateAddConstant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAddConstant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAddConstant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAddConstantArgs<'args>) -> flatbuffers::WIPOffset<GateAddConstant<'bldr>> {
      let mut builder = GateAddConstantBuilder::new(_fbb);
      if let Some(x) = args.constant { builder.add_constant(x); }
      if let Some(x) = args.input { builder.add_input(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateAddConstant::VT_OUTPUT, None)
  }
  #[inline]
  pub fn input(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateAddConstant::VT_INPUT, None)
  }
  #[inline]
  pub fn constant(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateAddConstant::VT_CONSTANT, None).map(|v| v.safe_slice())
  }
}

pub struct GateAddConstantArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub input: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GateAddConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAddConstantArgs {
            output: None,
            input: None,
            constant: None,
        }
    }
}
pub struct GateAddConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateAddConstant::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateAddConstant::VT_INPUT, input);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateAddConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAddConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateMulConstantOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateMulConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMulConstant<'a> {
    type Inner = GateMulConstant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateMulConstant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateMulConstant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateMulConstantArgs<'args>) -> flatbuffers::WIPOffset<GateMulConstant<'bldr>> {
      let mut builder = GateMulConstantBuilder::new(_fbb);
      if let Some(x) = args.constant { builder.add_constant(x); }
      if let Some(x) = args.input { builder.add_input(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateMulConstant::VT_OUTPUT, None)
  }
  #[inline]
  pub fn input(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateMulConstant::VT_INPUT, None)
  }
  #[inline]
  pub fn constant(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateMulConstant::VT_CONSTANT, None).map(|v| v.safe_slice())
  }
}

pub struct GateMulConstantArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub input: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GateMulConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateMulConstantArgs {
            output: None,
            input: None,
            constant: None,
        }
    }
}
pub struct GateMulConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateMulConstant::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateMulConstant::VT_INPUT, input);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateMulConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMulConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAndOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAnd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAnd<'a> {
    type Inner = GateAnd<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAnd<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAnd {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAndArgs<'args>) -> flatbuffers::WIPOffset<GateAnd<'bldr>> {
      let mut builder = GateAndBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateAnd::VT_OUTPUT, None)
  }
  #[inline]
  pub fn left(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateAnd::VT_LEFT, None)
  }
  #[inline]
  pub fn right(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateAnd::VT_RIGHT, None)
  }
}

pub struct GateAndArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub left: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub right: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateAndArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAndArgs {
            output: None,
            left: None,
            right: None,
        }
    }
}
pub struct GateAndBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAndBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateAnd::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_left(&mut self, left: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateAnd::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right(&mut self, right: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateAnd::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAndBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAndBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAnd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateXorOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateXor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateXor<'a> {
    type Inner = GateXor<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateXor<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateXor {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateXorArgs<'args>) -> flatbuffers::WIPOffset<GateXor<'bldr>> {
      let mut builder = GateXorBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateXor::VT_OUTPUT, None)
  }
  #[inline]
  pub fn left(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateXor::VT_LEFT, None)
  }
  #[inline]
  pub fn right(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateXor::VT_RIGHT, None)
  }
}

pub struct GateXorArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub left: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub right: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateXorArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateXorArgs {
            output: None,
            left: None,
            right: None,
        }
    }
}
pub struct GateXorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateXorBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateXor::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_left(&mut self, left: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateXor::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right(&mut self, right: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateXor::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateXorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateXorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateXor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateNotOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateNot<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateNot<'a> {
    type Inner = GateNot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateNot<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateNot {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateNotArgs<'args>) -> flatbuffers::WIPOffset<GateNot<'bldr>> {
      let mut builder = GateNotBuilder::new(_fbb);
      if let Some(x) = args.input { builder.add_input(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateNot::VT_OUTPUT, None)
  }
  #[inline]
  pub fn input(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateNot::VT_INPUT, None)
  }
}

pub struct GateNotArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub input: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateNotArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateNotArgs {
            output: None,
            input: None,
        }
    }
}
pub struct GateNotBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateNotBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateNot::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateNot::VT_INPUT, input);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateNotBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateNotBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateNot<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateInstanceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateInstance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateInstance<'a> {
    type Inner = GateInstance<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateInstance<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateInstance {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateInstanceArgs<'args>) -> flatbuffers::WIPOffset<GateInstance<'bldr>> {
      let mut builder = GateInstanceBuilder::new(_fbb);
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateInstance::VT_OUTPUT, None)
  }
}

pub struct GateInstanceArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateInstanceArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateInstanceArgs {
            output: None,
        }
    }
}
pub struct GateInstanceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateInstanceBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateInstance::VT_OUTPUT, output);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateInstanceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateInstanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateInstance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateWitnessOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateWitness<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateWitness<'a> {
    type Inner = GateWitness<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateWitness<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateWitness {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateWitnessArgs<'args>) -> flatbuffers::WIPOffset<GateWitness<'bldr>> {
      let mut builder = GateWitnessBuilder::new(_fbb);
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn output(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateWitness::VT_OUTPUT, None)
  }
}

pub struct GateWitnessArgs<'a> {
    pub output: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateWitnessArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateWitnessArgs {
            output: None,
        }
    }
}
pub struct GateWitnessBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateWitnessBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateWitness::VT_OUTPUT, output);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateWitnessBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateWitnessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateWitness<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateFreeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateFree<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateFree<'a> {
    type Inner = GateFree<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateFree<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateFree {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateFreeArgs<'args>) -> flatbuffers::WIPOffset<GateFree<'bldr>> {
      let mut builder = GateFreeBuilder::new(_fbb);
      if let Some(x) = args.last { builder.add_last(x); }
      if let Some(x) = args.first { builder.add_first(x); }
      builder.finish()
    }

    pub const VT_FIRST: flatbuffers::VOffsetT = 4;
    pub const VT_LAST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn first(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateFree::VT_FIRST, None)
  }
  #[inline]
  pub fn last(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateFree::VT_LAST, None)
  }
}

pub struct GateFreeArgs<'a> {
    pub first: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub last: Option<flatbuffers::WIPOffset<Wire<'a >>>,
}
impl<'a> Default for GateFreeArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateFreeArgs {
            first: None,
            last: None,
        }
    }
}
pub struct GateFreeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateFreeBuilder<'a, 'b> {
  #[inline]
  pub fn add_first(&mut self, first: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateFree::VT_FIRST, first);
  }
  #[inline]
  pub fn add_last(&mut self, last: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateFree::VT_LAST, last);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateFreeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateFreeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateFree<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FunctionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Function<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Function<'a> {
    type Inner = Function<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Function<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Function {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FunctionArgs<'args>) -> flatbuffers::WIPOffset<Function<'bldr>> {
      let mut builder = FunctionBuilder::new(_fbb);
      builder.add_witness_count(args.witness_count);
      builder.add_instance_count(args.instance_count);
      builder.add_input_count(args.input_count);
      builder.add_output_count(args.output_count);
      if let Some(x) = args.body { builder.add_body(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_INPUT_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_INSTANCE_COUNT: flatbuffers::VOffsetT = 10;
    pub const VT_WITNESS_COUNT: flatbuffers::VOffsetT = 12;
    pub const VT_BODY: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Function::VT_NAME, None)
  }
  #[inline]
  pub fn output_count(&self) -> u64 {
    self._tab.get::<u64>(Function::VT_OUTPUT_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn input_count(&self) -> u64 {
    self._tab.get::<u64>(Function::VT_INPUT_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn instance_count(&self) -> u64 {
    self._tab.get::<u64>(Function::VT_INSTANCE_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn witness_count(&self) -> u64 {
    self._tab.get::<u64>(Function::VT_WITNESS_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Directive<'a>>>>>(Function::VT_BODY, None)
  }
}

pub struct FunctionArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub output_count: u64,
    pub input_count: u64,
    pub instance_count: u64,
    pub witness_count: u64,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Directive<'a >>>>>,
}
impl<'a> Default for FunctionArgs<'a> {
    #[inline]
    fn default() -> Self {
        FunctionArgs {
            name: None,
            output_count: 0,
            input_count: 0,
            instance_count: 0,
            witness_count: 0,
            body: None,
        }
    }
}
pub struct FunctionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FunctionBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_NAME, name);
  }
  #[inline]
  pub fn add_output_count(&mut self, output_count: u64) {
    self.fbb_.push_slot::<u64>(Function::VT_OUTPUT_COUNT, output_count, 0);
  }
  #[inline]
  pub fn add_input_count(&mut self, input_count: u64) {
    self.fbb_.push_slot::<u64>(Function::VT_INPUT_COUNT, input_count, 0);
  }
  #[inline]
  pub fn add_instance_count(&mut self, instance_count: u64) {
    self.fbb_.push_slot::<u64>(Function::VT_INSTANCE_COUNT, instance_count, 0);
  }
  #[inline]
  pub fn add_witness_count(&mut self, witness_count: u64) {
    self.fbb_.push_slot::<u64>(Function::VT_WITNESS_COUNT, witness_count, 0);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directive<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunctionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FunctionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Function<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateCallOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateCall<'a> {
    type Inner = GateCall<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateCall<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateCall {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateCallArgs<'args>) -> flatbuffers::WIPOffset<GateCall<'bldr>> {
      let mut builder = GateCallBuilder::new(_fbb);
      if let Some(x) = args.input_wires { builder.add_input_wires(x); }
      if let Some(x) = args.output_wires { builder.add_output_wires(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_WIRES: flatbuffers::VOffsetT = 6;
    pub const VT_INPUT_WIRES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GateCall::VT_NAME, None)
  }
  #[inline]
  pub fn output_wires(&self) -> Option<WireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WireList<'a>>>(GateCall::VT_OUTPUT_WIRES, None)
  }
  #[inline]
  pub fn input_wires(&self) -> Option<WireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WireList<'a>>>(GateCall::VT_INPUT_WIRES, None)
  }
}

pub struct GateCallArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub output_wires: Option<flatbuffers::WIPOffset<WireList<'a >>>,
    pub input_wires: Option<flatbuffers::WIPOffset<WireList<'a >>>,
}
impl<'a> Default for GateCallArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateCallArgs {
            name: None,
            output_wires: None,
            input_wires: None,
        }
    }
}
pub struct GateCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_NAME, name);
  }
  #[inline]
  pub fn add_output_wires(&mut self, output_wires: flatbuffers::WIPOffset<WireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WireList>>(GateCall::VT_OUTPUT_WIRES, output_wires);
  }
  #[inline]
  pub fn add_input_wires(&mut self, input_wires: flatbuffers::WIPOffset<WireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WireList>>(GateCall::VT_INPUT_WIRES, input_wires);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAnonCallOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAnonCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAnonCall<'a> {
    type Inner = GateAnonCall<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAnonCall<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAnonCall {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAnonCallArgs<'args>) -> flatbuffers::WIPOffset<GateAnonCall<'bldr>> {
      let mut builder = GateAnonCallBuilder::new(_fbb);
      if let Some(x) = args.inner { builder.add_inner(x); }
      if let Some(x) = args.output_wires { builder.add_output_wires(x); }
      builder.finish()
    }

    pub const VT_OUTPUT_WIRES: flatbuffers::VOffsetT = 4;
    pub const VT_INNER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn output_wires(&self) -> Option<WireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WireList<'a>>>(GateAnonCall::VT_OUTPUT_WIRES, None)
  }
  #[inline]
  pub fn inner(&self) -> Option<AbstractAnonCall<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<AbstractAnonCall<'a>>>(GateAnonCall::VT_INNER, None)
  }
}

pub struct GateAnonCallArgs<'a> {
    pub output_wires: Option<flatbuffers::WIPOffset<WireList<'a >>>,
    pub inner: Option<flatbuffers::WIPOffset<AbstractAnonCall<'a >>>,
}
impl<'a> Default for GateAnonCallArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAnonCallArgs {
            output_wires: None,
            inner: None,
        }
    }
}
pub struct GateAnonCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAnonCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_output_wires(&mut self, output_wires: flatbuffers::WIPOffset<WireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WireList>>(GateAnonCall::VT_OUTPUT_WIRES, output_wires);
  }
  #[inline]
  pub fn add_inner(&mut self, inner: flatbuffers::WIPOffset<AbstractAnonCall<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AbstractAnonCall>>(GateAnonCall::VT_INNER, inner);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAnonCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAnonCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAnonCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AbstractGateCallOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

/// The two Abstract types cannot exist by themselves in a circuit,
/// they MUST be included in another gate (For / Switch / Call / ...)
/// because they don't specify output wires, which should be specified in the
/// encompassing structure itself.
pub struct AbstractGateCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AbstractGateCall<'a> {
    type Inner = AbstractGateCall<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AbstractGateCall<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AbstractGateCall {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AbstractGateCallArgs<'args>) -> flatbuffers::WIPOffset<AbstractGateCall<'bldr>> {
      let mut builder = AbstractGateCallBuilder::new(_fbb);
      if let Some(x) = args.input_wires { builder.add_input_wires(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT_WIRES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AbstractGateCall::VT_NAME, None)
  }
  #[inline]
  pub fn input_wires(&self) -> Option<WireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WireList<'a>>>(AbstractGateCall::VT_INPUT_WIRES, None)
  }
}

pub struct AbstractGateCallArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub input_wires: Option<flatbuffers::WIPOffset<WireList<'a >>>,
}
impl<'a> Default for AbstractGateCallArgs<'a> {
    #[inline]
    fn default() -> Self {
        AbstractGateCallArgs {
            name: None,
            input_wires: None,
        }
    }
}
pub struct AbstractGateCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AbstractGateCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AbstractGateCall::VT_NAME, name);
  }
  #[inline]
  pub fn add_input_wires(&mut self, input_wires: flatbuffers::WIPOffset<WireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WireList>>(AbstractGateCall::VT_INPUT_WIRES, input_wires);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AbstractGateCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AbstractGateCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AbstractGateCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AbstractAnonCallOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AbstractAnonCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AbstractAnonCall<'a> {
    type Inner = AbstractAnonCall<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AbstractAnonCall<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AbstractAnonCall {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AbstractAnonCallArgs<'args>) -> flatbuffers::WIPOffset<AbstractAnonCall<'bldr>> {
      let mut builder = AbstractAnonCallBuilder::new(_fbb);
      builder.add_witness_count(args.witness_count);
      builder.add_instance_count(args.instance_count);
      if let Some(x) = args.subcircuit { builder.add_subcircuit(x); }
      if let Some(x) = args.input_wires { builder.add_input_wires(x); }
      builder.finish()
    }

    pub const VT_INPUT_WIRES: flatbuffers::VOffsetT = 4;
    pub const VT_INSTANCE_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_WITNESS_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_SUBCIRCUIT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn input_wires(&self) -> Option<WireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WireList<'a>>>(AbstractAnonCall::VT_INPUT_WIRES, None)
  }
  #[inline]
  pub fn instance_count(&self) -> u64 {
    self._tab.get::<u64>(AbstractAnonCall::VT_INSTANCE_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn witness_count(&self) -> u64 {
    self._tab.get::<u64>(AbstractAnonCall::VT_WITNESS_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn subcircuit(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Directive<'a>>>>>(AbstractAnonCall::VT_SUBCIRCUIT, None)
  }
}

pub struct AbstractAnonCallArgs<'a> {
    pub input_wires: Option<flatbuffers::WIPOffset<WireList<'a >>>,
    pub instance_count: u64,
    pub witness_count: u64,
    pub subcircuit: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Directive<'a >>>>>,
}
impl<'a> Default for AbstractAnonCallArgs<'a> {
    #[inline]
    fn default() -> Self {
        AbstractAnonCallArgs {
            input_wires: None,
            instance_count: 0,
            witness_count: 0,
            subcircuit: None,
        }
    }
}
pub struct AbstractAnonCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AbstractAnonCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_input_wires(&mut self, input_wires: flatbuffers::WIPOffset<WireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WireList>>(AbstractAnonCall::VT_INPUT_WIRES, input_wires);
  }
  #[inline]
  pub fn add_instance_count(&mut self, instance_count: u64) {
    self.fbb_.push_slot::<u64>(AbstractAnonCall::VT_INSTANCE_COUNT, instance_count, 0);
  }
  #[inline]
  pub fn add_witness_count(&mut self, witness_count: u64) {
    self.fbb_.push_slot::<u64>(AbstractAnonCall::VT_WITNESS_COUNT, witness_count, 0);
  }
  #[inline]
  pub fn add_subcircuit(&mut self, subcircuit: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directive<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AbstractAnonCall::VT_SUBCIRCUIT, subcircuit);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AbstractAnonCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AbstractAnonCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AbstractAnonCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CaseInvokeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CaseInvoke<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CaseInvoke<'a> {
    type Inner = CaseInvoke<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CaseInvoke<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CaseInvoke {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CaseInvokeArgs) -> flatbuffers::WIPOffset<CaseInvoke<'bldr>> {
      let mut builder = CaseInvokeBuilder::new(_fbb);
      if let Some(x) = args.invocation { builder.add_invocation(x); }
      builder.add_invocation_type(args.invocation_type);
      builder.finish()
    }

    pub const VT_INVOCATION_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_INVOCATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn invocation_type(&self) -> CaseInvokeU {
    self._tab.get::<CaseInvokeU>(CaseInvoke::VT_INVOCATION_TYPE, Some(CaseInvokeU::NONE)).unwrap()
  }
  #[inline]
  pub fn invocation(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(CaseInvoke::VT_INVOCATION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn invocation_as_abstract_gate_call(&self) -> Option<AbstractGateCall<'a>> {
    if self.invocation_type() == CaseInvokeU::AbstractGateCall {
      self.invocation().map(|u| AbstractGateCall::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn invocation_as_abstract_anon_call(&self) -> Option<AbstractAnonCall<'a>> {
    if self.invocation_type() == CaseInvokeU::AbstractAnonCall {
      self.invocation().map(|u| AbstractAnonCall::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct CaseInvokeArgs {
    pub invocation_type: CaseInvokeU,
    pub invocation: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for CaseInvokeArgs {
    #[inline]
    fn default() -> Self {
        CaseInvokeArgs {
            invocation_type: CaseInvokeU::NONE,
            invocation: None,
        }
    }
}
pub struct CaseInvokeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CaseInvokeBuilder<'a, 'b> {
  #[inline]
  pub fn add_invocation_type(&mut self, invocation_type: CaseInvokeU) {
    self.fbb_.push_slot::<CaseInvokeU>(CaseInvoke::VT_INVOCATION_TYPE, invocation_type, CaseInvokeU::NONE);
  }
  #[inline]
  pub fn add_invocation(&mut self, invocation: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CaseInvoke::VT_INVOCATION, invocation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CaseInvokeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CaseInvokeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CaseInvoke<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateSwitchOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateSwitch<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateSwitch<'a> {
    type Inner = GateSwitch<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateSwitch<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateSwitch {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateSwitchArgs<'args>) -> flatbuffers::WIPOffset<GateSwitch<'bldr>> {
      let mut builder = GateSwitchBuilder::new(_fbb);
      if let Some(x) = args.branches { builder.add_branches(x); }
      if let Some(x) = args.cases { builder.add_cases(x); }
      if let Some(x) = args.output_wires { builder.add_output_wires(x); }
      if let Some(x) = args.condition { builder.add_condition(x); }
      builder.finish()
    }

    pub const VT_CONDITION: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_WIRES: flatbuffers::VOffsetT = 6;
    pub const VT_CASES: flatbuffers::VOffsetT = 8;
    pub const VT_BRANCHES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn condition(&self) -> Option<Wire<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Wire<'a>>>(GateSwitch::VT_CONDITION, None)
  }
  #[inline]
  pub fn output_wires(&self) -> Option<WireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WireList<'a>>>(GateSwitch::VT_OUTPUT_WIRES, None)
  }
  #[inline]
  pub fn cases(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Value<'a>>>>>(GateSwitch::VT_CASES, None)
  }
  #[inline]
  pub fn branches(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CaseInvoke<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CaseInvoke<'a>>>>>(GateSwitch::VT_BRANCHES, None)
  }
}

pub struct GateSwitchArgs<'a> {
    pub condition: Option<flatbuffers::WIPOffset<Wire<'a >>>,
    pub output_wires: Option<flatbuffers::WIPOffset<WireList<'a >>>,
    pub cases: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Value<'a >>>>>,
    pub branches: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CaseInvoke<'a >>>>>,
}
impl<'a> Default for GateSwitchArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateSwitchArgs {
            condition: None,
            output_wires: None,
            cases: None,
            branches: None,
        }
    }
}
pub struct GateSwitchBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateSwitchBuilder<'a, 'b> {
  #[inline]
  pub fn add_condition(&mut self, condition: flatbuffers::WIPOffset<Wire<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Wire>>(GateSwitch::VT_CONDITION, condition);
  }
  #[inline]
  pub fn add_output_wires(&mut self, output_wires: flatbuffers::WIPOffset<WireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WireList>>(GateSwitch::VT_OUTPUT_WIRES, output_wires);
  }
  #[inline]
  pub fn add_cases(&mut self, cases: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateSwitch::VT_CASES, cases);
  }
  #[inline]
  pub fn add_branches(&mut self, branches: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CaseInvoke<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateSwitch::VT_BRANCHES, branches);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateSwitchBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateSwitchBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateSwitch<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprWireNumberOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprWireNumber<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprWireNumber<'a> {
    type Inner = IterExprWireNumber<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprWireNumber<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprWireNumber {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprWireNumberArgs) -> flatbuffers::WIPOffset<IterExprWireNumber<'bldr>> {
      let mut builder = IterExprWireNumberBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      builder.add_value_type(args.value_type);
      builder.finish()
    }

    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn value_type(&self) -> IterExpr {
    self._tab.get::<IterExpr>(IterExprWireNumber::VT_VALUE_TYPE, Some(IterExpr::NONE)).unwrap()
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IterExprWireNumber::VT_VALUE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_iter_expr_const(&self) -> Option<IterExprConst<'a>> {
    if self.value_type() == IterExpr::IterExprConst {
      self.value().map(|u| IterExprConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_iter_expr_name(&self) -> Option<IterExprName<'a>> {
    if self.value_type() == IterExpr::IterExprName {
      self.value().map(|u| IterExprName::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_iter_expr_add(&self) -> Option<IterExprAdd<'a>> {
    if self.value_type() == IterExpr::IterExprAdd {
      self.value().map(|u| IterExprAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_iter_expr_sub(&self) -> Option<IterExprSub<'a>> {
    if self.value_type() == IterExpr::IterExprSub {
      self.value().map(|u| IterExprSub::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_iter_expr_mul(&self) -> Option<IterExprMul<'a>> {
    if self.value_type() == IterExpr::IterExprMul {
      self.value().map(|u| IterExprMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_iter_expr_div_const(&self) -> Option<IterExprDivConst<'a>> {
    if self.value_type() == IterExpr::IterExprDivConst {
      self.value().map(|u| IterExprDivConst::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct IterExprWireNumberArgs {
    pub value_type: IterExpr,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for IterExprWireNumberArgs {
    #[inline]
    fn default() -> Self {
        IterExprWireNumberArgs {
            value_type: IterExpr::NONE,
            value: None,
        }
    }
}
pub struct IterExprWireNumberBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprWireNumberBuilder<'a, 'b> {
  #[inline]
  pub fn add_value_type(&mut self, value_type: IterExpr) {
    self.fbb_.push_slot::<IterExpr>(IterExprWireNumber::VT_VALUE_TYPE, value_type, IterExpr::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprWireNumber::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprWireNumberBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprWireNumberBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprWireNumber<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprConstOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprConst<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprConst<'a> {
    type Inner = IterExprConst<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprConst<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprConst {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprConstArgs) -> flatbuffers::WIPOffset<IterExprConst<'bldr>> {
      let mut builder = IterExprConstBuilder::new(_fbb);
      builder.add_value(args.value);
      builder.finish()
    }

    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn value(&self) -> u64 {
    self._tab.get::<u64>(IterExprConst::VT_VALUE, Some(0)).unwrap()
  }
}

pub struct IterExprConstArgs {
    pub value: u64,
}
impl<'a> Default for IterExprConstArgs {
    #[inline]
    fn default() -> Self {
        IterExprConstArgs {
            value: 0,
        }
    }
}
pub struct IterExprConstBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprConstBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(IterExprConst::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprConstBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprConstBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprConst<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprNameOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprName<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprName<'a> {
    type Inner = IterExprName<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprName<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprName {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprNameArgs<'args>) -> flatbuffers::WIPOffset<IterExprName<'bldr>> {
      let mut builder = IterExprNameBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IterExprName::VT_NAME, None)
  }
}

pub struct IterExprNameArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for IterExprNameArgs<'a> {
    #[inline]
    fn default() -> Self {
        IterExprNameArgs {
            name: None,
        }
    }
}
pub struct IterExprNameBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprNameBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprName::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprNameBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprNameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprName<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprAddOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprAdd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprAdd<'a> {
    type Inner = IterExprAdd<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprAdd<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprAdd {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprAddArgs) -> flatbuffers::WIPOffset<IterExprAdd<'bldr>> {
      let mut builder = IterExprAddBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      builder.add_right_type(args.right_type);
      builder.add_left_type(args.left_type);
      builder.finish()
    }

    pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn left_type(&self) -> IterExpr {
    self._tab.get::<IterExpr>(IterExprAdd::VT_LEFT_TYPE, Some(IterExpr::NONE)).unwrap()
  }
  #[inline]
  pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IterExprAdd::VT_LEFT, None)
  }
  #[inline]
  pub fn right_type(&self) -> IterExpr {
    self._tab.get::<IterExpr>(IterExprAdd::VT_RIGHT_TYPE, Some(IterExpr::NONE)).unwrap()
  }
  #[inline]
  pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IterExprAdd::VT_RIGHT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_const(&self) -> Option<IterExprConst<'a>> {
    if self.left_type() == IterExpr::IterExprConst {
      self.left().map(|u| IterExprConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_name(&self) -> Option<IterExprName<'a>> {
    if self.left_type() == IterExpr::IterExprName {
      self.left().map(|u| IterExprName::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_add(&self) -> Option<IterExprAdd<'a>> {
    if self.left_type() == IterExpr::IterExprAdd {
      self.left().map(|u| IterExprAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_sub(&self) -> Option<IterExprSub<'a>> {
    if self.left_type() == IterExpr::IterExprSub {
      self.left().map(|u| IterExprSub::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_mul(&self) -> Option<IterExprMul<'a>> {
    if self.left_type() == IterExpr::IterExprMul {
      self.left().map(|u| IterExprMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_div_const(&self) -> Option<IterExprDivConst<'a>> {
    if self.left_type() == IterExpr::IterExprDivConst {
      self.left().map(|u| IterExprDivConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_const(&self) -> Option<IterExprConst<'a>> {
    if self.right_type() == IterExpr::IterExprConst {
      self.right().map(|u| IterExprConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_name(&self) -> Option<IterExprName<'a>> {
    if self.right_type() == IterExpr::IterExprName {
      self.right().map(|u| IterExprName::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_add(&self) -> Option<IterExprAdd<'a>> {
    if self.right_type() == IterExpr::IterExprAdd {
      self.right().map(|u| IterExprAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_sub(&self) -> Option<IterExprSub<'a>> {
    if self.right_type() == IterExpr::IterExprSub {
      self.right().map(|u| IterExprSub::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_mul(&self) -> Option<IterExprMul<'a>> {
    if self.right_type() == IterExpr::IterExprMul {
      self.right().map(|u| IterExprMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_div_const(&self) -> Option<IterExprDivConst<'a>> {
    if self.right_type() == IterExpr::IterExprDivConst {
      self.right().map(|u| IterExprDivConst::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct IterExprAddArgs {
    pub left_type: IterExpr,
    pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub right_type: IterExpr,
    pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for IterExprAddArgs {
    #[inline]
    fn default() -> Self {
        IterExprAddArgs {
            left_type: IterExpr::NONE,
            left: None,
            right_type: IterExpr::NONE,
            right: None,
        }
    }
}
pub struct IterExprAddBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprAddBuilder<'a, 'b> {
  #[inline]
  pub fn add_left_type(&mut self, left_type: IterExpr) {
    self.fbb_.push_slot::<IterExpr>(IterExprAdd::VT_LEFT_TYPE, left_type, IterExpr::NONE);
  }
  #[inline]
  pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprAdd::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right_type(&mut self, right_type: IterExpr) {
    self.fbb_.push_slot::<IterExpr>(IterExprAdd::VT_RIGHT_TYPE, right_type, IterExpr::NONE);
  }
  #[inline]
  pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprAdd::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprAddBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprAddBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprAdd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprSubOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprSub<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprSub<'a> {
    type Inner = IterExprSub<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprSub<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprSub {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprSubArgs) -> flatbuffers::WIPOffset<IterExprSub<'bldr>> {
      let mut builder = IterExprSubBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      builder.add_right_type(args.right_type);
      builder.add_left_type(args.left_type);
      builder.finish()
    }

    pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn left_type(&self) -> IterExpr {
    self._tab.get::<IterExpr>(IterExprSub::VT_LEFT_TYPE, Some(IterExpr::NONE)).unwrap()
  }
  #[inline]
  pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IterExprSub::VT_LEFT, None)
  }
  #[inline]
  pub fn right_type(&self) -> IterExpr {
    self._tab.get::<IterExpr>(IterExprSub::VT_RIGHT_TYPE, Some(IterExpr::NONE)).unwrap()
  }
  #[inline]
  pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IterExprSub::VT_RIGHT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_const(&self) -> Option<IterExprConst<'a>> {
    if self.left_type() == IterExpr::IterExprConst {
      self.left().map(|u| IterExprConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_name(&self) -> Option<IterExprName<'a>> {
    if self.left_type() == IterExpr::IterExprName {
      self.left().map(|u| IterExprName::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_add(&self) -> Option<IterExprAdd<'a>> {
    if self.left_type() == IterExpr::IterExprAdd {
      self.left().map(|u| IterExprAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_sub(&self) -> Option<IterExprSub<'a>> {
    if self.left_type() == IterExpr::IterExprSub {
      self.left().map(|u| IterExprSub::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_mul(&self) -> Option<IterExprMul<'a>> {
    if self.left_type() == IterExpr::IterExprMul {
      self.left().map(|u| IterExprMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_div_const(&self) -> Option<IterExprDivConst<'a>> {
    if self.left_type() == IterExpr::IterExprDivConst {
      self.left().map(|u| IterExprDivConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_const(&self) -> Option<IterExprConst<'a>> {
    if self.right_type() == IterExpr::IterExprConst {
      self.right().map(|u| IterExprConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_name(&self) -> Option<IterExprName<'a>> {
    if self.right_type() == IterExpr::IterExprName {
      self.right().map(|u| IterExprName::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_add(&self) -> Option<IterExprAdd<'a>> {
    if self.right_type() == IterExpr::IterExprAdd {
      self.right().map(|u| IterExprAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_sub(&self) -> Option<IterExprSub<'a>> {
    if self.right_type() == IterExpr::IterExprSub {
      self.right().map(|u| IterExprSub::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_mul(&self) -> Option<IterExprMul<'a>> {
    if self.right_type() == IterExpr::IterExprMul {
      self.right().map(|u| IterExprMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_div_const(&self) -> Option<IterExprDivConst<'a>> {
    if self.right_type() == IterExpr::IterExprDivConst {
      self.right().map(|u| IterExprDivConst::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct IterExprSubArgs {
    pub left_type: IterExpr,
    pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub right_type: IterExpr,
    pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for IterExprSubArgs {
    #[inline]
    fn default() -> Self {
        IterExprSubArgs {
            left_type: IterExpr::NONE,
            left: None,
            right_type: IterExpr::NONE,
            right: None,
        }
    }
}
pub struct IterExprSubBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprSubBuilder<'a, 'b> {
  #[inline]
  pub fn add_left_type(&mut self, left_type: IterExpr) {
    self.fbb_.push_slot::<IterExpr>(IterExprSub::VT_LEFT_TYPE, left_type, IterExpr::NONE);
  }
  #[inline]
  pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprSub::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right_type(&mut self, right_type: IterExpr) {
    self.fbb_.push_slot::<IterExpr>(IterExprSub::VT_RIGHT_TYPE, right_type, IterExpr::NONE);
  }
  #[inline]
  pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprSub::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprSubBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprSubBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprSub<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprMulOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprMul<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprMul<'a> {
    type Inner = IterExprMul<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprMul<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprMul {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprMulArgs) -> flatbuffers::WIPOffset<IterExprMul<'bldr>> {
      let mut builder = IterExprMulBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      builder.add_right_type(args.right_type);
      builder.add_left_type(args.left_type);
      builder.finish()
    }

    pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn left_type(&self) -> IterExpr {
    self._tab.get::<IterExpr>(IterExprMul::VT_LEFT_TYPE, Some(IterExpr::NONE)).unwrap()
  }
  #[inline]
  pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IterExprMul::VT_LEFT, None)
  }
  #[inline]
  pub fn right_type(&self) -> IterExpr {
    self._tab.get::<IterExpr>(IterExprMul::VT_RIGHT_TYPE, Some(IterExpr::NONE)).unwrap()
  }
  #[inline]
  pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IterExprMul::VT_RIGHT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_const(&self) -> Option<IterExprConst<'a>> {
    if self.left_type() == IterExpr::IterExprConst {
      self.left().map(|u| IterExprConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_name(&self) -> Option<IterExprName<'a>> {
    if self.left_type() == IterExpr::IterExprName {
      self.left().map(|u| IterExprName::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_add(&self) -> Option<IterExprAdd<'a>> {
    if self.left_type() == IterExpr::IterExprAdd {
      self.left().map(|u| IterExprAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_sub(&self) -> Option<IterExprSub<'a>> {
    if self.left_type() == IterExpr::IterExprSub {
      self.left().map(|u| IterExprSub::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_mul(&self) -> Option<IterExprMul<'a>> {
    if self.left_type() == IterExpr::IterExprMul {
      self.left().map(|u| IterExprMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_iter_expr_div_const(&self) -> Option<IterExprDivConst<'a>> {
    if self.left_type() == IterExpr::IterExprDivConst {
      self.left().map(|u| IterExprDivConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_const(&self) -> Option<IterExprConst<'a>> {
    if self.right_type() == IterExpr::IterExprConst {
      self.right().map(|u| IterExprConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_name(&self) -> Option<IterExprName<'a>> {
    if self.right_type() == IterExpr::IterExprName {
      self.right().map(|u| IterExprName::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_add(&self) -> Option<IterExprAdd<'a>> {
    if self.right_type() == IterExpr::IterExprAdd {
      self.right().map(|u| IterExprAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_sub(&self) -> Option<IterExprSub<'a>> {
    if self.right_type() == IterExpr::IterExprSub {
      self.right().map(|u| IterExprSub::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_mul(&self) -> Option<IterExprMul<'a>> {
    if self.right_type() == IterExpr::IterExprMul {
      self.right().map(|u| IterExprMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_iter_expr_div_const(&self) -> Option<IterExprDivConst<'a>> {
    if self.right_type() == IterExpr::IterExprDivConst {
      self.right().map(|u| IterExprDivConst::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct IterExprMulArgs {
    pub left_type: IterExpr,
    pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub right_type: IterExpr,
    pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for IterExprMulArgs {
    #[inline]
    fn default() -> Self {
        IterExprMulArgs {
            left_type: IterExpr::NONE,
            left: None,
            right_type: IterExpr::NONE,
            right: None,
        }
    }
}
pub struct IterExprMulBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprMulBuilder<'a, 'b> {
  #[inline]
  pub fn add_left_type(&mut self, left_type: IterExpr) {
    self.fbb_.push_slot::<IterExpr>(IterExprMul::VT_LEFT_TYPE, left_type, IterExpr::NONE);
  }
  #[inline]
  pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprMul::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right_type(&mut self, right_type: IterExpr) {
    self.fbb_.push_slot::<IterExpr>(IterExprMul::VT_RIGHT_TYPE, right_type, IterExpr::NONE);
  }
  #[inline]
  pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprMul::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprMulBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprMulBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprMul<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprDivConstOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprDivConst<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprDivConst<'a> {
    type Inner = IterExprDivConst<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprDivConst<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprDivConst {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprDivConstArgs<'args>) -> flatbuffers::WIPOffset<IterExprDivConst<'bldr>> {
      let mut builder = IterExprDivConstBuilder::new(_fbb);
      if let Some(x) = args.denom { builder.add_denom(x); }
      if let Some(x) = args.numer { builder.add_numer(x); }
      builder.add_numer_type(args.numer_type);
      builder.finish()
    }

    pub const VT_NUMER_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NUMER: flatbuffers::VOffsetT = 6;
    pub const VT_DENOM: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn numer_type(&self) -> IterExpr {
    self._tab.get::<IterExpr>(IterExprDivConst::VT_NUMER_TYPE, Some(IterExpr::NONE)).unwrap()
  }
  #[inline]
  pub fn numer(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IterExprDivConst::VT_NUMER, None)
  }
  #[inline]
  pub fn denom(&self) -> Option<IterExprConst<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IterExprConst<'a>>>(IterExprDivConst::VT_DENOM, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn numer_as_iter_expr_const(&self) -> Option<IterExprConst<'a>> {
    if self.numer_type() == IterExpr::IterExprConst {
      self.numer().map(|u| IterExprConst::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn numer_as_iter_expr_name(&self) -> Option<IterExprName<'a>> {
    if self.numer_type() == IterExpr::IterExprName {
      self.numer().map(|u| IterExprName::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn numer_as_iter_expr_add(&self) -> Option<IterExprAdd<'a>> {
    if self.numer_type() == IterExpr::IterExprAdd {
      self.numer().map(|u| IterExprAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn numer_as_iter_expr_sub(&self) -> Option<IterExprSub<'a>> {
    if self.numer_type() == IterExpr::IterExprSub {
      self.numer().map(|u| IterExprSub::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn numer_as_iter_expr_mul(&self) -> Option<IterExprMul<'a>> {
    if self.numer_type() == IterExpr::IterExprMul {
      self.numer().map(|u| IterExprMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn numer_as_iter_expr_div_const(&self) -> Option<IterExprDivConst<'a>> {
    if self.numer_type() == IterExpr::IterExprDivConst {
      self.numer().map(|u| IterExprDivConst::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct IterExprDivConstArgs<'a> {
    pub numer_type: IterExpr,
    pub numer: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub denom: Option<flatbuffers::WIPOffset<IterExprConst<'a >>>,
}
impl<'a> Default for IterExprDivConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        IterExprDivConstArgs {
            numer_type: IterExpr::NONE,
            numer: None,
            denom: None,
        }
    }
}
pub struct IterExprDivConstBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprDivConstBuilder<'a, 'b> {
  #[inline]
  pub fn add_numer_type(&mut self, numer_type: IterExpr) {
    self.fbb_.push_slot::<IterExpr>(IterExprDivConst::VT_NUMER_TYPE, numer_type, IterExpr::NONE);
  }
  #[inline]
  pub fn add_numer(&mut self, numer: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprDivConst::VT_NUMER, numer);
  }
  #[inline]
  pub fn add_denom(&mut self, denom: flatbuffers::WIPOffset<IterExprConst<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IterExprConst>>(IterExprDivConst::VT_DENOM, denom);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprDivConstBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprDivConstBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprDivConst<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprWireRangeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprWireRange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprWireRange<'a> {
    type Inner = IterExprWireRange<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprWireRange<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprWireRange {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprWireRangeArgs<'args>) -> flatbuffers::WIPOffset<IterExprWireRange<'bldr>> {
      let mut builder = IterExprWireRangeBuilder::new(_fbb);
      if let Some(x) = args.last { builder.add_last(x); }
      if let Some(x) = args.first { builder.add_first(x); }
      builder.finish()
    }

    pub const VT_FIRST: flatbuffers::VOffsetT = 4;
    pub const VT_LAST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn first(&self) -> Option<IterExprWireNumber<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IterExprWireNumber<'a>>>(IterExprWireRange::VT_FIRST, None)
  }
  #[inline]
  pub fn last(&self) -> Option<IterExprWireNumber<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IterExprWireNumber<'a>>>(IterExprWireRange::VT_LAST, None)
  }
}

pub struct IterExprWireRangeArgs<'a> {
    pub first: Option<flatbuffers::WIPOffset<IterExprWireNumber<'a >>>,
    pub last: Option<flatbuffers::WIPOffset<IterExprWireNumber<'a >>>,
}
impl<'a> Default for IterExprWireRangeArgs<'a> {
    #[inline]
    fn default() -> Self {
        IterExprWireRangeArgs {
            first: None,
            last: None,
        }
    }
}
pub struct IterExprWireRangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprWireRangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_first(&mut self, first: flatbuffers::WIPOffset<IterExprWireNumber<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IterExprWireNumber>>(IterExprWireRange::VT_FIRST, first);
  }
  #[inline]
  pub fn add_last(&mut self, last: flatbuffers::WIPOffset<IterExprWireNumber<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IterExprWireNumber>>(IterExprWireRange::VT_LAST, last);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprWireRangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprWireRangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprWireRange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprWireListElementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprWireListElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprWireListElement<'a> {
    type Inner = IterExprWireListElement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprWireListElement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprWireListElement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprWireListElementArgs) -> flatbuffers::WIPOffset<IterExprWireListElement<'bldr>> {
      let mut builder = IterExprWireListElementBuilder::new(_fbb);
      if let Some(x) = args.element { builder.add_element(x); }
      builder.add_element_type(args.element_type);
      builder.finish()
    }

    pub const VT_ELEMENT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ELEMENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn element_type(&self) -> IterExprWireListElementU {
    self._tab.get::<IterExprWireListElementU>(IterExprWireListElement::VT_ELEMENT_TYPE, Some(IterExprWireListElementU::NONE)).unwrap()
  }
  #[inline]
  pub fn element(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IterExprWireListElement::VT_ELEMENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_iter_expr_wire_number(&self) -> Option<IterExprWireNumber<'a>> {
    if self.element_type() == IterExprWireListElementU::IterExprWireNumber {
      self.element().map(|u| IterExprWireNumber::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_iter_expr_wire_range(&self) -> Option<IterExprWireRange<'a>> {
    if self.element_type() == IterExprWireListElementU::IterExprWireRange {
      self.element().map(|u| IterExprWireRange::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct IterExprWireListElementArgs {
    pub element_type: IterExprWireListElementU,
    pub element: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for IterExprWireListElementArgs {
    #[inline]
    fn default() -> Self {
        IterExprWireListElementArgs {
            element_type: IterExprWireListElementU::NONE,
            element: None,
        }
    }
}
pub struct IterExprWireListElementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprWireListElementBuilder<'a, 'b> {
  #[inline]
  pub fn add_element_type(&mut self, element_type: IterExprWireListElementU) {
    self.fbb_.push_slot::<IterExprWireListElementU>(IterExprWireListElement::VT_ELEMENT_TYPE, element_type, IterExprWireListElementU::NONE);
  }
  #[inline]
  pub fn add_element(&mut self, element: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprWireListElement::VT_ELEMENT, element);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprWireListElementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprWireListElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprWireListElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprWireListOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprWireList<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprWireList<'a> {
    type Inner = IterExprWireList<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprWireList<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprWireList {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprWireListArgs<'args>) -> flatbuffers::WIPOffset<IterExprWireList<'bldr>> {
      let mut builder = IterExprWireListBuilder::new(_fbb);
      if let Some(x) = args.elements { builder.add_elements(x); }
      builder.finish()
    }

    pub const VT_ELEMENTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IterExprWireListElement<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<IterExprWireListElement<'a>>>>>(IterExprWireList::VT_ELEMENTS, None)
  }
}

pub struct IterExprWireListArgs<'a> {
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<IterExprWireListElement<'a >>>>>,
}
impl<'a> Default for IterExprWireListArgs<'a> {
    #[inline]
    fn default() -> Self {
        IterExprWireListArgs {
            elements: None,
        }
    }
}
pub struct IterExprWireListBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprWireListBuilder<'a, 'b> {
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IterExprWireListElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprWireList::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprWireListBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprWireListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprWireList<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprFunctionInvokeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprFunctionInvoke<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprFunctionInvoke<'a> {
    type Inner = IterExprFunctionInvoke<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprFunctionInvoke<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprFunctionInvoke {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprFunctionInvokeArgs<'args>) -> flatbuffers::WIPOffset<IterExprFunctionInvoke<'bldr>> {
      let mut builder = IterExprFunctionInvokeBuilder::new(_fbb);
      if let Some(x) = args.inputs { builder.add_inputs(x); }
      if let Some(x) = args.outputs { builder.add_outputs(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 6;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IterExprFunctionInvoke::VT_NAME, None)
  }
  #[inline]
  pub fn outputs(&self) -> Option<IterExprWireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IterExprWireList<'a>>>(IterExprFunctionInvoke::VT_OUTPUTS, None)
  }
  #[inline]
  pub fn inputs(&self) -> Option<IterExprWireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IterExprWireList<'a>>>(IterExprFunctionInvoke::VT_INPUTS, None)
  }
}

pub struct IterExprFunctionInvokeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub outputs: Option<flatbuffers::WIPOffset<IterExprWireList<'a >>>,
    pub inputs: Option<flatbuffers::WIPOffset<IterExprWireList<'a >>>,
}
impl<'a> Default for IterExprFunctionInvokeArgs<'a> {
    #[inline]
    fn default() -> Self {
        IterExprFunctionInvokeArgs {
            name: None,
            outputs: None,
            inputs: None,
        }
    }
}
pub struct IterExprFunctionInvokeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprFunctionInvokeBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprFunctionInvoke::VT_NAME, name);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<IterExprWireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IterExprWireList>>(IterExprFunctionInvoke::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<IterExprWireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IterExprWireList>>(IterExprFunctionInvoke::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprFunctionInvokeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprFunctionInvokeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprFunctionInvoke<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IterExprAnonFunctionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IterExprAnonFunction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IterExprAnonFunction<'a> {
    type Inner = IterExprAnonFunction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IterExprAnonFunction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IterExprAnonFunction {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IterExprAnonFunctionArgs<'args>) -> flatbuffers::WIPOffset<IterExprAnonFunction<'bldr>> {
      let mut builder = IterExprAnonFunctionBuilder::new(_fbb);
      builder.add_witness_count(args.witness_count);
      builder.add_instance_count(args.instance_count);
      if let Some(x) = args.body { builder.add_body(x); }
      if let Some(x) = args.inputs { builder.add_inputs(x); }
      if let Some(x) = args.outputs { builder.add_outputs(x); }
      builder.finish()
    }

    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 4;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
    pub const VT_INSTANCE_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_WITNESS_COUNT: flatbuffers::VOffsetT = 10;
    pub const VT_BODY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn outputs(&self) -> Option<IterExprWireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IterExprWireList<'a>>>(IterExprAnonFunction::VT_OUTPUTS, None)
  }
  #[inline]
  pub fn inputs(&self) -> Option<IterExprWireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IterExprWireList<'a>>>(IterExprAnonFunction::VT_INPUTS, None)
  }
  #[inline]
  pub fn instance_count(&self) -> u64 {
    self._tab.get::<u64>(IterExprAnonFunction::VT_INSTANCE_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn witness_count(&self) -> u64 {
    self._tab.get::<u64>(IterExprAnonFunction::VT_WITNESS_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Directive<'a>>>>>(IterExprAnonFunction::VT_BODY, None)
  }
}

pub struct IterExprAnonFunctionArgs<'a> {
    pub outputs: Option<flatbuffers::WIPOffset<IterExprWireList<'a >>>,
    pub inputs: Option<flatbuffers::WIPOffset<IterExprWireList<'a >>>,
    pub instance_count: u64,
    pub witness_count: u64,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Directive<'a >>>>>,
}
impl<'a> Default for IterExprAnonFunctionArgs<'a> {
    #[inline]
    fn default() -> Self {
        IterExprAnonFunctionArgs {
            outputs: None,
            inputs: None,
            instance_count: 0,
            witness_count: 0,
            body: None,
        }
    }
}
pub struct IterExprAnonFunctionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IterExprAnonFunctionBuilder<'a, 'b> {
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<IterExprWireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IterExprWireList>>(IterExprAnonFunction::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<IterExprWireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IterExprWireList>>(IterExprAnonFunction::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_instance_count(&mut self, instance_count: u64) {
    self.fbb_.push_slot::<u64>(IterExprAnonFunction::VT_INSTANCE_COUNT, instance_count, 0);
  }
  #[inline]
  pub fn add_witness_count(&mut self, witness_count: u64) {
    self.fbb_.push_slot::<u64>(IterExprAnonFunction::VT_WITNESS_COUNT, witness_count, 0);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directive<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IterExprAnonFunction::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IterExprAnonFunctionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IterExprAnonFunctionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IterExprAnonFunction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateForOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateFor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateFor<'a> {
    type Inner = GateFor<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateFor<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateFor {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateForArgs<'args>) -> flatbuffers::WIPOffset<GateFor<'bldr>> {
      let mut builder = GateForBuilder::new(_fbb);
      builder.add_last(args.last);
      builder.add_first(args.first);
      if let Some(x) = args.body { builder.add_body(x); }
      if let Some(x) = args.iterator { builder.add_iterator(x); }
      if let Some(x) = args.outputs { builder.add_outputs(x); }
      builder.add_body_type(args.body_type);
      builder.finish()
    }

    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 4;
    pub const VT_ITERATOR: flatbuffers::VOffsetT = 6;
    pub const VT_FIRST: flatbuffers::VOffsetT = 8;
    pub const VT_LAST: flatbuffers::VOffsetT = 10;
    pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_BODY: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn outputs(&self) -> Option<WireList<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WireList<'a>>>(GateFor::VT_OUTPUTS, None)
  }
  #[inline]
  pub fn iterator(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GateFor::VT_ITERATOR, None)
  }
  #[inline]
  pub fn first(&self) -> u64 {
    self._tab.get::<u64>(GateFor::VT_FIRST, Some(0)).unwrap()
  }
  #[inline]
  pub fn last(&self) -> u64 {
    self._tab.get::<u64>(GateFor::VT_LAST, Some(0)).unwrap()
  }
  #[inline]
  pub fn body_type(&self) -> ForLoopBody {
    self._tab.get::<ForLoopBody>(GateFor::VT_BODY_TYPE, Some(ForLoopBody::NONE)).unwrap()
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(GateFor::VT_BODY, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_iter_expr_function_invoke(&self) -> Option<IterExprFunctionInvoke<'a>> {
    if self.body_type() == ForLoopBody::IterExprFunctionInvoke {
      self.body().map(|u| IterExprFunctionInvoke::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_iter_expr_anon_function(&self) -> Option<IterExprAnonFunction<'a>> {
    if self.body_type() == ForLoopBody::IterExprAnonFunction {
      self.body().map(|u| IterExprAnonFunction::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct GateForArgs<'a> {
    pub outputs: Option<flatbuffers::WIPOffset<WireList<'a >>>,
    pub iterator: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub first: u64,
    pub last: u64,
    pub body_type: ForLoopBody,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for GateForArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateForArgs {
            outputs: None,
            iterator: None,
            first: 0,
            last: 0,
            body_type: ForLoopBody::NONE,
            body: None,
        }
    }
}
pub struct GateForBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateForBuilder<'a, 'b> {
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<WireList<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WireList>>(GateFor::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_iterator(&mut self, iterator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateFor::VT_ITERATOR, iterator);
  }
  #[inline]
  pub fn add_first(&mut self, first: u64) {
    self.fbb_.push_slot::<u64>(GateFor::VT_FIRST, first, 0);
  }
  #[inline]
  pub fn add_last(&mut self, last: u64) {
    self.fbb_.push_slot::<u64>(GateFor::VT_LAST, last, 0);
  }
  #[inline]
  pub fn add_body_type(&mut self, body_type: ForLoopBody) {
    self.fbb_.push_slot::<ForLoopBody>(GateFor::VT_BODY_TYPE, body_type, ForLoopBody::NONE);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateFor::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateForBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateForBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateFor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DirectiveOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Directive<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Directive<'a> {
    type Inner = Directive<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Directive<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Directive {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DirectiveArgs) -> flatbuffers::WIPOffset<Directive<'bldr>> {
      let mut builder = DirectiveBuilder::new(_fbb);
      if let Some(x) = args.directive { builder.add_directive(x); }
      builder.add_directive_type(args.directive_type);
      builder.finish()
    }

    pub const VT_DIRECTIVE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_DIRECTIVE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn directive_type(&self) -> DirectiveSet {
    self._tab.get::<DirectiveSet>(Directive::VT_DIRECTIVE_TYPE, Some(DirectiveSet::NONE)).unwrap()
  }
  #[inline]
  pub fn directive(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Directive::VT_DIRECTIVE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_constant(&self) -> Option<GateConstant<'a>> {
    if self.directive_type() == DirectiveSet::GateConstant {
      self.directive().map(|u| GateConstant::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_assert_zero(&self) -> Option<GateAssertZero<'a>> {
    if self.directive_type() == DirectiveSet::GateAssertZero {
      self.directive().map(|u| GateAssertZero::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_copy(&self) -> Option<GateCopy<'a>> {
    if self.directive_type() == DirectiveSet::GateCopy {
      self.directive().map(|u| GateCopy::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_add(&self) -> Option<GateAdd<'a>> {
    if self.directive_type() == DirectiveSet::GateAdd {
      self.directive().map(|u| GateAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_mul(&self) -> Option<GateMul<'a>> {
    if self.directive_type() == DirectiveSet::GateMul {
      self.directive().map(|u| GateMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_add_constant(&self) -> Option<GateAddConstant<'a>> {
    if self.directive_type() == DirectiveSet::GateAddConstant {
      self.directive().map(|u| GateAddConstant::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_mul_constant(&self) -> Option<GateMulConstant<'a>> {
    if self.directive_type() == DirectiveSet::GateMulConstant {
      self.directive().map(|u| GateMulConstant::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_and(&self) -> Option<GateAnd<'a>> {
    if self.directive_type() == DirectiveSet::GateAnd {
      self.directive().map(|u| GateAnd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_xor(&self) -> Option<GateXor<'a>> {
    if self.directive_type() == DirectiveSet::GateXor {
      self.directive().map(|u| GateXor::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_not(&self) -> Option<GateNot<'a>> {
    if self.directive_type() == DirectiveSet::GateNot {
      self.directive().map(|u| GateNot::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_instance(&self) -> Option<GateInstance<'a>> {
    if self.directive_type() == DirectiveSet::GateInstance {
      self.directive().map(|u| GateInstance::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_witness(&self) -> Option<GateWitness<'a>> {
    if self.directive_type() == DirectiveSet::GateWitness {
      self.directive().map(|u| GateWitness::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_free(&self) -> Option<GateFree<'a>> {
    if self.directive_type() == DirectiveSet::GateFree {
      self.directive().map(|u| GateFree::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_call(&self) -> Option<GateCall<'a>> {
    if self.directive_type() == DirectiveSet::GateCall {
      self.directive().map(|u| GateCall::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_anon_call(&self) -> Option<GateAnonCall<'a>> {
    if self.directive_type() == DirectiveSet::GateAnonCall {
      self.directive().map(|u| GateAnonCall::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_switch(&self) -> Option<GateSwitch<'a>> {
    if self.directive_type() == DirectiveSet::GateSwitch {
      self.directive().map(|u| GateSwitch::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate_for(&self) -> Option<GateFor<'a>> {
    if self.directive_type() == DirectiveSet::GateFor {
      self.directive().map(|u| GateFor::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct DirectiveArgs {
    pub directive_type: DirectiveSet,
    pub directive: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DirectiveArgs {
    #[inline]
    fn default() -> Self {
        DirectiveArgs {
            directive_type: DirectiveSet::NONE,
            directive: None,
        }
    }
}
pub struct DirectiveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DirectiveBuilder<'a, 'b> {
  #[inline]
  pub fn add_directive_type(&mut self, directive_type: DirectiveSet) {
    self.fbb_.push_slot::<DirectiveSet>(Directive::VT_DIRECTIVE_TYPE, directive_type, DirectiveSet::NONE);
  }
  #[inline]
  pub fn add_directive(&mut self, directive: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Directive::VT_DIRECTIVE, directive);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirectiveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DirectiveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Directive<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RootOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Root<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Root<'a> {
    type Inner = Root<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Root<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Root {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RootArgs) -> flatbuffers::WIPOffset<Root<'bldr>> {
      let mut builder = RootBuilder::new(_fbb);
      if let Some(x) = args.message { builder.add_message(x); }
      builder.add_message_type(args.message_type);
      builder.finish()
    }

    pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn message_type(&self) -> Message {
    self._tab.get::<Message>(Root::VT_MESSAGE_TYPE, Some(Message::NONE)).unwrap()
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Root::VT_MESSAGE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_relation(&self) -> Option<Relation<'a>> {
    if self.message_type() == Message::Relation {
      self.message().map(|u| Relation::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_instance(&self) -> Option<Instance<'a>> {
    if self.message_type() == Message::Instance {
      self.message().map(|u| Instance::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_witness(&self) -> Option<Witness<'a>> {
    if self.message_type() == Message::Witness {
      self.message().map(|u| Witness::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct RootArgs {
    pub message_type: Message,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RootArgs {
    #[inline]
    fn default() -> Self {
        RootArgs {
            message_type: Message::NONE,
            message: None,
        }
    }
}
pub struct RootBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RootBuilder<'a, 'b> {
  #[inline]
  pub fn add_message_type(&mut self, message_type: Message) {
    self.fbb_.push_slot::<Message>(Root::VT_MESSAGE_TYPE, message_type, Message::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Root::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RootBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RootBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Root<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_root::<Root<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_size_prefixed_root::<Root<'a>>(buf)
}

pub const ROOT_IDENTIFIER: &'static str = "siev";

#[inline]
pub fn root_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, false);
}

#[inline]
pub fn root_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, true);
}

pub const ROOT_EXTENSION: &'static str = "sieve";

#[inline]
pub fn finish_root_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish(root, Some(ROOT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_root_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish_size_prefixed(root, Some(ROOT_IDENTIFIER));
}
}  // pub mod sieve_ir

