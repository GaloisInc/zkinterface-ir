// This is a FlatBuffers schema.
// See https://google.github.io/flatbuffers/

namespace sieve_ir;

// ==== Message types that can be exchanged. ====

union Message {
   Relation,
   Instance,
   Witness,
}

table Header {
   version              :string;
   field_characteristic :Value;
   field_degree         :uint32;
}

table Relation {
   header               :Header;
   gateset              :string;
   features             :string;
   functions            :[Function];
   gates                :[Gate];
}

table Instance {
   header               :Header;
   common_inputs        :[Value];
}

table Witness {
   header               :Header;
   short_witness        :[Value];
}


// ==== Helper types ====

table Wire {
    id          :uint64;
}

// Field element is encoded in a vector of bytes in little-endian order.
// There is no minimum or maximum length; trailing zeros may be omitted.
table Value {
    value        :[ubyte];
}

table WireRange {
    first      :Wire;
    last       :Wire;
}

union WireListElementU {
    Wire,
    WireRange,
}

table WireListElement {
    element   :WireListElementU;
}

table WireList {
    elements    :[WireListElement];
}

// ==== Gate types ====

table GateConstant {
   output      :Wire;
   constant    :[ubyte];
}

table GateAssertZero {
   input       :Wire;
}

table GateCopy {
   output      :Wire;
   input       :Wire;
}

table GateAdd {
   output      :Wire;
   left        :Wire;
   right       :Wire;
}

table GateMul {
   output      :Wire;
   left        :Wire;
   right       :Wire;
}

table GateAddConstant {
   output      :Wire;
   input       :Wire;
   constant    :[ubyte];
}

table GateMulConstant {
   output      :Wire;
   input       :Wire;
   constant    :[ubyte];
}

table GateAnd {
   output      :Wire;
   left        :Wire;
   right       :Wire;
}

table GateXor {
   output      :Wire;
   left        :Wire;
   right       :Wire;
}

table GateNot {
   output      :Wire;
   input       :Wire;
}

table GateInstance {
   output      :Wire;
}

table GateWitness {
   output      :Wire;
}

table GateFree {
   // First wire ID to free.
   first       :Wire;
   // Last wire ID is optional. Free the range [first; last] inclusive.
   last        :Wire;
}

table Function {
    // Declare a Function gate as a custom computation
    name            :string;
    output_count    :uint64;
    input_count     :uint64;
    instance_count  :uint64;
    witness_count   :uint64;
    body            :Block;
}

table GateCall {
    // Invokes a previously defined Function gate
    name              :string;
    output_wires      :WireList;
    input_wires       :WireList;
}

/// The two Abstract types cannot exist by themselves in a circuit,
/// they MUST be included in another gate (For / Switch / Call / ...)
table AbstractGateCall {
    // Invokes a previously defined Function gate
    name              :string;
    input_wires       :WireList;
}

table GateAnonCall {
    output_wires    :WireList;
    inner           :AbstractAnonCall;
}


table AbstractAnonCall {
    input_wires     :WireList;
    instance_count  :uint64;
    witness_count   :uint64;
    subcircuit      :Block;
}

union CaseInvokeU {
    AbstractGateCall,
    AbstractAnonCall,
}

table CaseInvoke {
    invocation  :CaseInvokeU;
}

table GateSwitch {
    condition         :Wire;
    output_wires      :WireList;
    cases             :[Value];
    branches          :[CaseInvoke];
}

/* ========== For loop related stuff  ========== */
union IterExpr {
    IterExprConst,
    IterExprName,
    IterExprAdd,
    IterExprSub,
    IterExprMul,
}

table IterExprWireNumber { value :IterExpr;}

// Constant value in an expression
table IterExprConst { value :uint64; }
// Named loop-iteration
table IterExprName { name : string; }
// Sum of two expressions
table IterExprAdd { left :IterExpr; right :IterExpr; }
// Difference of two expressions
table IterExprSub { left :IterExpr; right :IterExpr; }
// Product of two expressions
table IterExprMul { left :IterExpr; right :IterExpr; }

table IterExprWireRange {
    first :IterExprWireNumber;
    last  :IterExprWireNumber;
}

union IterExprWireListElementU {
    IterExprWireNumber,
    IterExprWireRange,
}
table IterExprWireListElement { element: IterExprWireListElementU; }

table IterExprWireList {
    elements :[IterExprWireListElement];
}

table IterExprFunctionInvoke {
  name     :string;
  outputs  :IterExprWireList;
  inputs   :IterExprWireList;
}

table IterExprAnonFunction {
  outputs          :IterExprWireList;
  inputs           :IterExprWireList;
  instance_count   :uint64;
  witness_count    :uint64;
  body             :Block;
}

union ForLoopBody {
  IterExprFunctionInvoke,
  IterExprAnonFunction
}

table GateFor {
  outputs     :WireList;
  iterator    :string;
  first       :uint64;
  last        :uint64;
  body        :ForLoopBody;
}

/* ========== For loop related stuff  ========== */

union GateSet {
   GateConstant,
   GateAssertZero,
   GateCopy,
   GateAdd,
   GateMul,
   GateAddConstant,
   GateMulConstant,
   GateAnd,
   GateXor,
   GateNot,
   GateInstance,
   GateWitness,
   GateFree,
   GateCall,
   GateAnonCall,
   GateSwitch,
   GateFor,
}

table Gate {
    gate      :GateSet;
}

table Block {
    block   :[Gate];
}

// ==== Flatbuffers details ====

// All message types are encapsulated in the FlatBuffers root table.
table Root {
    message                 :Message;
}
root_type Root;

// When storing messages to files, this extension and identifier should be used.
file_extension "sieve";
file_identifier "siev"; // a.k.a. magic bytes.

// Message framing:
//
// All messages must be prefixed by the size of the message,
// not including the prefix, as a 4-bytes little-endian unsigned integer.
