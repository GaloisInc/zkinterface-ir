// This is a FlatBuffers schema.
// See https://google.github.io/flatbuffers/
namespace sieve_ir;

// ==== Message types that can be exchanged. ====
union Message {
   Relation,
   PublicInputs,
   PrivateInputs,
}

// The 'version' field should match the following regexp "^\d+.\d+.\d+$"
table Relation {
   version              :string;
   types                :[Value];
   plugins              :[string];
   functions            :[Function];
   directives           :[Directive];
}

table PublicInputs {
   version              :string;
   types                :[Value];
   inputs               :[Inputs];
}

table PrivateInputs {
   version              :string;
   types                :[Value];
   inputs               :[Inputs];
}

table Inputs {
	values              :[Value];
}

// ==== Helper types ====

// Type element is encoded in a vector of bytes in little-endian order.
// There is no minimum or maximum length; trailing zeros may be omitted.
table Value {
    value        :[ubyte];
}

table Count {
	type_id    :ubyte;
	count      :uint64;
}

// first/last are inclusive
table WireRange {
    first_id   :uint64;
    last_id    :uint64;
}

// ==== Gate types ====

table GateConstant {
   type_id     :ubyte;
   out_id      :uint64;
   constant    :[ubyte];
}

table GateAssertZero {
   type_id     :ubyte;
   in_id       :uint64;
}

table GateCopy {
   type_id     :ubyte;
   out_id      :uint64;
   in_id       :uint64;
}

table GateAdd {
   type_id     :ubyte;
   out_id      :uint64;
   left_id     :uint64;
   right_id    :uint64;
}

table GateMul {
   type_id     :ubyte;
   out_id      :uint64;
   left_id     :uint64;
   right_id    :uint64;
}

table GateAddConstant {
   type_id     :ubyte;
   out_id      :uint64;
   in_id       :uint64;
   constant    :[ubyte];
}

table GateMulConstant {
   type_id     :ubyte;
   out_id      :uint64;
   in_id       :uint64;
   constant    :[ubyte];
}

table GatePublicInput {
   type_id     :ubyte;
   out_id      :uint64;
}

table GatePrivateInput {
   type_id     :ubyte;
   out_id      :uint64;
}

// To allocate in a contiguous space all wires between the first and the last inclusive.
table GateNew {
   type_id     :ubyte;
   first_id    :uint64;
   last_id     :uint64;
}

// To deallocate wires between first and last inclusive
table GateDelete {
   type_id     :ubyte;
   first_id    :uint64;
   last_id     :uint64;
}

table GateConvert {
  out_type_id  :ubyte;
  out_first_id :uint64;
  out_last_id  :uint64;
  in_type_id   :ubyte;
  in_first_id  :uint64;
  in_last_id   :uint64;
}

union FunctionBody {
	Gates,
	PluginBody,
}

table Gates {
	gates          :[Directive];
}

table PluginBody {
	name          :string;
	operation     :string;
	params        :[string];
    public_count    :[Count]; // Each type_id must be unique
    private_count   :[Count]; // Each type_id must be unique
}

// Function declaration. The 'name' field is string matching the following pattern
//   [`a'-`z' | `A'-`Z' | `_']  [`a'-`z' | `A'-`Z' | `0'-`9' | `_']*
//   (
//       [`.' | `::']
//       [`a'-`z' | `A'-`Z' | `_']  [`a'-`z' | `A'-`Z' | `0'-`9' | `_']*
//   )*
table Function {
    // Declare a Function gate as a custom computation
    name            :string;
    output_count    :[Count];
    input_count     :[Count];
    body            :FunctionBody;
}

// Invokes a previously defined Function gate
table GateCall {
    name         :string;
    out_ids      :[WireRange];
    in_ids       :[WireRange];
}

union DirectiveSet {
   GateConstant,
   GateAssertZero,
   GateCopy,
   GateAdd,
   GateMul,
   GateAddConstant,
   GateMulConstant,
   GatePublicInput,
   GatePrivateInput,
   GateNew,
   GateDelete,
   GateConvert,
   GateCall,
}

table Directive {
    directive      :DirectiveSet;
}

// ==== Flatbuffers details ====

// All message types are encapsulated in the FlatBuffers root table.
table Root {
    message                 :Message;
}
root_type Root;

// When storing messages to files, this extension and identifier should be used.
file_extension "sieve";
file_identifier "siev"; // a.k.a. magic bytes.

// Message framing:
//
// All messages must be prefixed by the size of the message,
// not including the prefix, as a 4-bytes little-endian unsigned integer.
